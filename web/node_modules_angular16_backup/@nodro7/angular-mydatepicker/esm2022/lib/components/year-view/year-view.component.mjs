import { Component, EventEmitter, Input, Output, ViewEncapsulation } from "@angular/core";
import { KeyCode } from "../../enums/key-code.enum";
import { ActiveView } from "../../enums/active-view.enum";
import { UtilService } from "../../services/angular-mydatepicker.util.service";
import { YEARS, OPTS } from "../../constants/constants";
import * as i0 from "@angular/core";
import * as i1 from "../../services/angular-mydatepicker.util.service";
import * as i2 from "@angular/common";
export class YearViewComponent {
    constructor(utilService) {
        this.utilService = utilService;
        this.yearCellClicked = new EventEmitter();
        this.yearCellKeyDown = new EventEmitter();
        this.viewActivated = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes.hasOwnProperty(OPTS)) {
            this.opts = changes[OPTS].currentValue;
        }
        if (changes.hasOwnProperty(YEARS)) {
            this.years = changes[YEARS].currentValue;
        }
    }
    ngAfterViewInit() {
        this.viewActivated.emit(ActiveView.Year);
    }
    onYearCellClicked(event, cell) {
        event.stopPropagation();
        if (cell.disabled) {
            return;
        }
        this.yearCellClicked.emit(cell);
    }
    onYearCellKeyDown(event, cell) {
        const keyCode = this.utilService.getKeyCodeFromEvent(event);
        if (keyCode !== KeyCode.tab) {
            event.preventDefault();
            if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {
                this.onYearCellClicked(event, cell);
            }
            else if (this.opts.moveFocusByArrowKeys) {
                this.yearCellKeyDown.emit(event);
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: YearViewComponent, deps: [{ token: i1.UtilService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.0.0", type: YearViewComponent, selector: "lib-year-view", inputs: { opts: "opts", years: "years", viewChanged: "viewChanged" }, outputs: { yearCellClicked: "yearCellClicked", yearCellKeyDown: "yearCellKeyDown", viewActivated: "viewActivated" }, providers: [UtilService], usesOnChanges: true, ngImport: i0, template: "<table class=\"myDpYearTable\" [ngClass]=\"{'ng-myrtl': opts.rtl, 'myDpFooter': opts.showFooterToday, 'myDpNoFooter': !opts.showFooterToday, 'myDpViewChangeAnimation': opts.viewChangeAnimation && viewChanged}\">\n  <tbody>\n    <tr *ngFor=\"let yr of years\">\n      <td *ngFor=\"let y of yr\"\n          id=\"y_{{y.row}}_{{y.col}}\"\n          class=\"y_{{y.row}}_{{y.col}} myDpYearcell\"\n          [ngClass]=\"{'myDpSelectedYear': y.selected, 'myDpDisabled': y.disabled, 'myDpTableSingleYear': !y.disabled}\"\n          [attr.aria-current]=\"y.currYear ? 'date' : null\"\n          [attr.aria-disabled]=\"y.disabled || null\"\n          [attr.aria-selected]=\"y.selected || null\"\n          [attr.tabindex]=\"!y.disabled ? 0 : -1\"\n          (click)=\"onYearCellClicked($event, y)\"\n          (keydown)=\"onYearCellKeyDown($event, y)\">\n        <span class=\"myDpYearValue\"\n          [attr.aria-label]=\"[(1 + '/' + 1 + '/' + y.year | date:'yyyy')]\"\n          [ngClass]=\"{'myDpMarkCurrYear': y.currYear && opts.markCurrentYear}\">{{y.year}}</span>\n      </td>\n    </tr>\n  </tbody>\n</table>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "pipe", type: i2.DatePipe, name: "date" }], encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: YearViewComponent, decorators: [{
            type: Component,
            args: [{ selector: "lib-year-view", providers: [UtilService], encapsulation: ViewEncapsulation.None, template: "<table class=\"myDpYearTable\" [ngClass]=\"{'ng-myrtl': opts.rtl, 'myDpFooter': opts.showFooterToday, 'myDpNoFooter': !opts.showFooterToday, 'myDpViewChangeAnimation': opts.viewChangeAnimation && viewChanged}\">\n  <tbody>\n    <tr *ngFor=\"let yr of years\">\n      <td *ngFor=\"let y of yr\"\n          id=\"y_{{y.row}}_{{y.col}}\"\n          class=\"y_{{y.row}}_{{y.col}} myDpYearcell\"\n          [ngClass]=\"{'myDpSelectedYear': y.selected, 'myDpDisabled': y.disabled, 'myDpTableSingleYear': !y.disabled}\"\n          [attr.aria-current]=\"y.currYear ? 'date' : null\"\n          [attr.aria-disabled]=\"y.disabled || null\"\n          [attr.aria-selected]=\"y.selected || null\"\n          [attr.tabindex]=\"!y.disabled ? 0 : -1\"\n          (click)=\"onYearCellClicked($event, y)\"\n          (keydown)=\"onYearCellKeyDown($event, y)\">\n        <span class=\"myDpYearValue\"\n          [attr.aria-label]=\"[(1 + '/' + 1 + '/' + y.year | date:'yyyy')]\"\n          [ngClass]=\"{'myDpMarkCurrYear': y.currYear && opts.markCurrentYear}\">{{y.year}}</span>\n      </td>\n    </tr>\n  </tbody>\n</table>\n" }]
        }], ctorParameters: function () { return [{ type: i1.UtilService }]; }, propDecorators: { opts: [{
                type: Input
            }], years: [{
                type: Input
            }], viewChanged: [{
                type: Input
            }], yearCellClicked: [{
                type: Output
            }], yearCellKeyDown: [{
                type: Output
            }], viewActivated: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItbXlkYXRlcGlja2VyL3NyYy9saWIvY29tcG9uZW50cy95ZWFyLXZpZXcveWVhci12aWV3LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItbXlkYXRlcGlja2VyL3NyYy9saWIvY29tcG9uZW50cy95ZWFyLXZpZXcveWVhci12aWV3LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBNEIsTUFBTSxFQUFpQixpQkFBaUIsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUdqSSxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDbEQsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLDhCQUE4QixDQUFDO0FBQ3hELE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxrREFBa0QsQ0FBQztBQUM3RSxPQUFPLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQyxNQUFNLDJCQUEyQixDQUFDOzs7O0FBUXRELE1BQU0sT0FBTyxpQkFBaUI7SUFTNUIsWUFBb0IsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFKbEMsb0JBQWUsR0FBa0MsSUFBSSxZQUFZLEVBQW1CLENBQUM7UUFDckYsb0JBQWUsR0FBc0IsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUM3RCxrQkFBYSxHQUE2QixJQUFJLFlBQVksRUFBYyxDQUFDO0lBRW5DLENBQUM7SUFFakQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNoQyxJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUM7U0FDeEM7UUFDRCxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDakMsSUFBSSxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWSxDQUFDO1NBQzFDO0lBQ0gsQ0FBQztJQUVELGVBQWU7UUFDYixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELGlCQUFpQixDQUFDLEtBQVUsRUFBRSxJQUFxQjtRQUNqRCxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFeEIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2pCLE9BQU87U0FDUjtRQUVELElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxpQkFBaUIsQ0FBQyxLQUFVLEVBQUUsSUFBcUI7UUFDakQsTUFBTSxPQUFPLEdBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwRSxJQUFJLE9BQU8sS0FBSyxPQUFPLENBQUMsR0FBRyxFQUFFO1lBQzNCLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUV2QixJQUFJLE9BQU8sS0FBSyxPQUFPLENBQUMsS0FBSyxJQUFJLE9BQU8sS0FBSyxPQUFPLENBQUMsS0FBSyxFQUFFO2dCQUMxRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ3JDO2lCQUNJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtnQkFDdkMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUE7YUFDakM7U0FDRjtJQUNILENBQUM7OEdBOUNVLGlCQUFpQjtrR0FBakIsaUJBQWlCLG1PQUhqQixDQUFDLFdBQVcsQ0FBQywrQ0NYMUIscWxDQW9CQTs7MkZETmEsaUJBQWlCO2tCQU43QixTQUFTOytCQUNFLGVBQWUsYUFFZCxDQUFDLFdBQVcsQ0FBQyxpQkFDVCxpQkFBaUIsQ0FBQyxJQUFJO2tHQUc1QixJQUFJO3NCQUFaLEtBQUs7Z0JBQ0csS0FBSztzQkFBYixLQUFLO2dCQUNHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBRUksZUFBZTtzQkFBeEIsTUFBTTtnQkFDRyxlQUFlO3NCQUF4QixNQUFNO2dCQUNHLGFBQWE7c0JBQXRCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMsIFZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHtJTXlDYWxlbmRhclllYXJ9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzL215LWNhbGVuZGFyLXllYXIuaW50ZXJmYWNlXCI7XG5pbXBvcnQge0lNeU9wdGlvbnN9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzL215LW9wdGlvbnMuaW50ZXJmYWNlXCI7XG5pbXBvcnQge0tleUNvZGV9IGZyb20gXCIuLi8uLi9lbnVtcy9rZXktY29kZS5lbnVtXCI7XG5pbXBvcnQge0FjdGl2ZVZpZXd9IGZyb20gXCIuLi8uLi9lbnVtcy9hY3RpdmUtdmlldy5lbnVtXCI7XG5pbXBvcnQge1V0aWxTZXJ2aWNlfSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYW5ndWxhci1teWRhdGVwaWNrZXIudXRpbC5zZXJ2aWNlXCI7XG5pbXBvcnQge1lFQVJTLCBPUFRTfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzL2NvbnN0YW50c1wiO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6IFwibGliLXllYXItdmlld1wiLFxuICB0ZW1wbGF0ZVVybDogXCIuL3llYXItdmlldy5jb21wb25lbnQuaHRtbFwiLFxuICBwcm92aWRlcnM6IFtVdGlsU2VydmljZV0sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgWWVhclZpZXdDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoKSBvcHRzOiBJTXlPcHRpb25zO1xuICBASW5wdXQoKSB5ZWFyczogQXJyYXk8QXJyYXk8SU15Q2FsZW5kYXJZZWFyPj47XG4gIEBJbnB1dCgpIHZpZXdDaGFuZ2VkOiBib29sZWFuO1xuXG4gIEBPdXRwdXQoKSB5ZWFyQ2VsbENsaWNrZWQ6IEV2ZW50RW1pdHRlcjxJTXlDYWxlbmRhclllYXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTXlDYWxlbmRhclllYXI+KCk7XG4gIEBPdXRwdXQoKSB5ZWFyQ2VsbEtleURvd246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIEBPdXRwdXQoKSB2aWV3QWN0aXZhdGVkOiBFdmVudEVtaXR0ZXI8QWN0aXZlVmlldz4gPSBuZXcgRXZlbnRFbWl0dGVyPEFjdGl2ZVZpZXc+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB1dGlsU2VydmljZTogVXRpbFNlcnZpY2UpIHsgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShPUFRTKSkge1xuICAgICAgdGhpcy5vcHRzID0gY2hhbmdlc1tPUFRTXS5jdXJyZW50VmFsdWU7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KFlFQVJTKSkge1xuICAgICAgdGhpcy55ZWFycyA9IGNoYW5nZXNbWUVBUlNdLmN1cnJlbnRWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy52aWV3QWN0aXZhdGVkLmVtaXQoQWN0aXZlVmlldy5ZZWFyKTtcbiAgfVxuXG4gIG9uWWVhckNlbGxDbGlja2VkKGV2ZW50OiBhbnksIGNlbGw6IElNeUNhbGVuZGFyWWVhcik6IHZvaWQge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKGNlbGwuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnllYXJDZWxsQ2xpY2tlZC5lbWl0KGNlbGwpO1xuICB9XG5cbiAgb25ZZWFyQ2VsbEtleURvd24oZXZlbnQ6IGFueSwgY2VsbDogSU15Q2FsZW5kYXJZZWFyKSB7XG4gICAgY29uc3Qga2V5Q29kZTogbnVtYmVyID0gdGhpcy51dGlsU2VydmljZS5nZXRLZXlDb2RlRnJvbUV2ZW50KGV2ZW50KTtcbiAgICBpZiAoa2V5Q29kZSAhPT0gS2V5Q29kZS50YWIpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmIChrZXlDb2RlID09PSBLZXlDb2RlLmVudGVyIHx8IGtleUNvZGUgPT09IEtleUNvZGUuc3BhY2UpIHtcbiAgICAgICAgdGhpcy5vblllYXJDZWxsQ2xpY2tlZChldmVudCwgY2VsbCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLm9wdHMubW92ZUZvY3VzQnlBcnJvd0tleXMpIHtcbiAgICAgICAgdGhpcy55ZWFyQ2VsbEtleURvd24uZW1pdChldmVudClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIjx0YWJsZSBjbGFzcz1cIm15RHBZZWFyVGFibGVcIiBbbmdDbGFzc109XCJ7J25nLW15cnRsJzogb3B0cy5ydGwsICdteURwRm9vdGVyJzogb3B0cy5zaG93Rm9vdGVyVG9kYXksICdteURwTm9Gb290ZXInOiAhb3B0cy5zaG93Rm9vdGVyVG9kYXksICdteURwVmlld0NoYW5nZUFuaW1hdGlvbic6IG9wdHMudmlld0NoYW5nZUFuaW1hdGlvbiAmJiB2aWV3Q2hhbmdlZH1cIj5cbiAgPHRib2R5PlxuICAgIDx0ciAqbmdGb3I9XCJsZXQgeXIgb2YgeWVhcnNcIj5cbiAgICAgIDx0ZCAqbmdGb3I9XCJsZXQgeSBvZiB5clwiXG4gICAgICAgICAgaWQ9XCJ5X3t7eS5yb3d9fV97e3kuY29sfX1cIlxuICAgICAgICAgIGNsYXNzPVwieV97e3kucm93fX1fe3t5LmNvbH19IG15RHBZZWFyY2VsbFwiXG4gICAgICAgICAgW25nQ2xhc3NdPVwieydteURwU2VsZWN0ZWRZZWFyJzogeS5zZWxlY3RlZCwgJ215RHBEaXNhYmxlZCc6IHkuZGlzYWJsZWQsICdteURwVGFibGVTaW5nbGVZZWFyJzogIXkuZGlzYWJsZWR9XCJcbiAgICAgICAgICBbYXR0ci5hcmlhLWN1cnJlbnRdPVwieS5jdXJyWWVhciA/ICdkYXRlJyA6IG51bGxcIlxuICAgICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwieS5kaXNhYmxlZCB8fCBudWxsXCJcbiAgICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cInkuc2VsZWN0ZWQgfHwgbnVsbFwiXG4gICAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwiIXkuZGlzYWJsZWQgPyAwIDogLTFcIlxuICAgICAgICAgIChjbGljayk9XCJvblllYXJDZWxsQ2xpY2tlZCgkZXZlbnQsIHkpXCJcbiAgICAgICAgICAoa2V5ZG93bik9XCJvblllYXJDZWxsS2V5RG93bigkZXZlbnQsIHkpXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibXlEcFllYXJWYWx1ZVwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJbKDEgKyAnLycgKyAxICsgJy8nICsgeS55ZWFyIHwgZGF0ZToneXl5eScpXVwiXG4gICAgICAgICAgW25nQ2xhc3NdPVwieydteURwTWFya0N1cnJZZWFyJzogeS5jdXJyWWVhciAmJiBvcHRzLm1hcmtDdXJyZW50WWVhcn1cIj57e3kueWVhcn19PC9zcGFuPlxuICAgICAgPC90ZD5cbiAgICA8L3RyPlxuICA8L3Rib2R5PlxuPC90YWJsZT5cbiJdfQ==