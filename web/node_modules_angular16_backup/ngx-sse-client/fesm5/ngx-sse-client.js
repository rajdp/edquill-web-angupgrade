import { __decorate } from 'tslib';
import { HttpEventType, HttpClient } from '@angular/common/http';
import { ɵɵdefineInjectable, ɵɵinject, Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { repeatWhen, retryWhen, takeWhile, delay, tap } from 'rxjs/operators';

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function () {
    if (typeof window.Event === 'function')
        return;
    var Event = /** @class */ (function () {
        function Event(type, eventInitDict) {
            if (eventInitDict === void 0) { eventInitDict = { bubbles: false, cancelable: false, composed: false }; }
            this.composedPath = function () { return []; };
            this.initEvent = function () { return undefined; };
            this.preventDefault = function () { return undefined; };
            this.stopImmediatePropagation = function () { return undefined; };
            this.stopPropagation = function () { return undefined; };
            this.type = type;
            this.bubbles = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.bubbles;
            this.cancelable = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.cancelable;
            this.composed = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.composed;
        }
        return Event;
    }());
    window.MessageEvent = /** @class */ (function (_super) {
        __extends(MessageEvent, _super);
        function MessageEvent(type, eventInitDict) {
            var _this = _super.call(this, type, eventInitDict) || this;
            _this.data = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.data;
            _this.lastEventId = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.lastEventId;
            _this.origin = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.origin;
            _this.ports = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.ports;
            _this.source = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.source;
            return _this;
        }
        return MessageEvent;
    }(Event));
    window.ErrorEvent = /** @class */ (function (_super) {
        __extends(ErrorEvent, _super);
        function ErrorEvent(type, eventInitDict) {
            var _this = _super.call(this, type, eventInitDict) || this;
            _this.colno = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.colno;
            _this.error = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.error;
            _this.filename = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.filename;
            _this.lineno = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.lineno;
            _this.message = eventInitDict === null || eventInitDict === void 0 ? void 0 : eventInitDict.message;
            return _this;
        }
        return ErrorEvent;
    }(Event));
})();

var defaultSseOptions = { keepAlive: true, reconnectionDelay: 3000, responseType: 'event' };

var defaultRequestOptions = { observe: 'events', reportProgress: true, responseType: 'text' };

var SseClient = /** @class */ (function () {
    function SseClient(httpClient) {
        this.httpClient = httpClient;
        this.progress = 0;
        this.chunk = '';
    }
    SseClient_1 = SseClient;
    SseClient.prototype.stream = function (url, options, requestOptions, method) {
        var _this = this;
        if (method === void 0) { method = 'GET'; }
        this.sseOptions = Object.assign({}, defaultSseOptions, options);
        this.httpClientOptions = Object.assign({}, requestOptions, defaultRequestOptions);
        return new Observable(function (observer) {
            var subscription = _this.subscribeStreamRequest(url, _this.sseOptions, _this.httpClientOptions, method, observer);
            return function () { return subscription.unsubscribe(); };
        });
    };
    SseClient.prototype.subscribeStreamRequest = function (url, options, requestOptions, method, observer) {
        var _this = this;
        return this.httpClient
            .request(method, url, requestOptions)
            .pipe(repeatWhen(function (completed) { return _this.repeatWhen(completed, options.keepAlive, options.reconnectionDelay); }))
            .pipe(retryWhen(function (error) { return _this.retryWhen(error, options.keepAlive, options.reconnectionDelay, observer); }))
            .subscribe(function (event) { return _this.parseStreamEvent(event, observer); });
    };
    SseClient.prototype.repeatWhen = function (completed, keepAlive, reconnectionDelay) {
        return completed.pipe(takeWhile(function () { return keepAlive; })).pipe(delay(reconnectionDelay));
    };
    SseClient.prototype.retryWhen = function (attempts, keepAlive, reconnectionDelay, observer) {
        var _this = this;
        return attempts
            .pipe(tap(function (error) { return _this.threatRequestError(error, observer); }))
            .pipe(takeWhile(function () { return keepAlive; }))
            .pipe(delay(reconnectionDelay));
    };
    SseClient.prototype.threatRequestError = function (event, observer) {
        this.dispatchStreamData(this.errorEvent(event), observer);
        if (!this.isValidStatus(event.status)) {
            observer.error(event);
        }
    };
    SseClient.prototype.isValidStatus = function (status) {
        return status !== undefined && status !== null && status <= 299;
    };
    SseClient.prototype.parseStreamEvent = function (event, observer) {
        if (event.type === HttpEventType.Sent) {
            this.progress = 0;
            return;
        }
        if (event.type === HttpEventType.DownloadProgress) {
            this.onStreamProgress(event.partialText, observer);
            return;
        }
        if (event.type === HttpEventType.Response) {
            this.onStreamCompleted(event, observer);
            return;
        }
    };
    SseClient.prototype.onStreamProgress = function (data, observer) {
        var _this = this;
        data = data.substring(this.progress);
        this.progress += data.length;
        data.split(/(\r\n|\r|\n){2}/g).forEach(function (part) { return _this.parseEventData(part, observer); });
    };
    SseClient.prototype.onStreamCompleted = function (response, observer) {
        this.onStreamProgress(response.body, observer);
        this.dispatchStreamData(this.parseEventChunk(this.chunk), observer);
        this.chunk = '';
        this.progress = 0;
        this.dispatchStreamData(this.errorEvent(), observer);
    };
    SseClient.prototype.parseEventData = function (part, observer) {
        if (part.trim().length === 0) {
            this.dispatchStreamData(this.parseEventChunk(this.chunk), observer);
            this.chunk = '';
        }
        else {
            this.chunk += part;
        }
    };
    SseClient.prototype.parseEventChunk = function (chunk) {
        var _this = this;
        if (!chunk || chunk.length === 0)
            return;
        var chunkEvent = { id: null, data: '', event: 'message' };
        chunk.split(/\n|\r\n|\r/).forEach(function (line) { return _this.parseChunkLine(line.trim(), chunkEvent); });
        return this.messageEvent(chunkEvent.event, { lastEventId: chunkEvent.id, data: chunkEvent.data });
    };
    SseClient.prototype.parseChunkLine = function (line, event) {
        var index = line.indexOf(SseClient_1.SEPARATOR);
        if (index <= 0)
            return null;
        var field = line.substring(0, index);
        if (Object.keys(event).findIndex(function (key) { return key === field; }) === -1)
            return;
        var data = line.substring(index + 1);
        if (field === 'data')
            data = event.data + data;
        event[field] = data;
    };
    SseClient.prototype.dispatchStreamData = function (event, observer) {
        if (!this.validEvent(event))
            return;
        if (this.sseOptions.responseType === 'event') {
            observer.next(event);
        }
        else {
            observer.next(event.data);
        }
    };
    SseClient.prototype.validEvent = function (event) {
        if (!event)
            return false;
        if (event.type === 'error' && this.sseOptions.responseType !== 'event')
            return false;
        if (event.type !== 'error' && (!event.data || !event.data.length))
            return false;
        return true;
    };
    SseClient.prototype.messageEvent = function (type, options) {
        return new MessageEvent(type, options);
    };
    SseClient.prototype.errorEvent = function (error) {
        var eventInitDict;
        if (error && error.status > 0) {
            eventInitDict = { error: error, message: error.message };
            if (!this.isValidStatus(error.status)) {
                eventInitDict['status'] = error.status;
                eventInitDict['statusText'] = error.statusText;
            }
        }
        return new ErrorEvent('error', eventInitDict);
    };
    var SseClient_1;
    SseClient.SEPARATOR = ':';
    SseClient.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    SseClient.ɵprov = ɵɵdefineInjectable({ factory: function SseClient_Factory() { return new SseClient(ɵɵinject(HttpClient)); }, token: SseClient, providedIn: "root" });
    SseClient = SseClient_1 = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], SseClient);
    return SseClient;
}());

/*
 * Public API Surface of ngx-sse-client
 */

/**
 * Generated bundle index. Do not edit.
 */

export { SseClient, defaultRequestOptions, defaultSseOptions };
//# sourceMappingURL=ngx-sse-client.js.map
