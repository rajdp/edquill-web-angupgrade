import * as i0 from '@angular/core';
import { Type, EventEmitter, OnChanges, OnDestroy, SimpleChange, ViewContainerRef, SimpleChanges, OnInit, PipeTransform, AfterViewInit, QueryList, ElementRef, Renderer2 } from '@angular/core';
import { Subject, Observable, Subscription } from 'rxjs';
import * as i2 from '@angular/common';
import { DomSanitizer, SafeHtml, SafeStyle, SafeScript, SafeUrl, SafeResourceUrl } from '@angular/platform-browser';
import { HttpClient, HttpParams } from '@angular/common/http';

interface Settings {
    columns: IColumns;
    resizable?: boolean;
    hideable?: boolean;
    hideTagList?: boolean;
    mode?: 'external' | 'inline';
    hideHeader?: boolean;
    hideSubHeader?: boolean;
    noDataMessage?: string;
    attr?: Attribute;
    actions?: Actions | false;
    edit?: EditAction;
    add?: AddAction;
    delete?: DeleteAction;
    filter?: Filter$1;
    expand?: Expand;
    pager?: Pager;
    rowClassFunction?: RowClassFunction;
    valueCreateFunction?: ValueCreateFunction;
    selectMode?: 'single' | 'multi' | 'multi_filtered';
    sortMode?: 'single' | 'multi';
    switchPageToSelectedRowPage?: boolean;
}
interface Filter$1 {
    inputClass?: string;
    debounceTime?: number;
}
interface Expand {
    /**
     * The angular component that shall be rendered when the row is expanded.
     * The data of the row is assigned to a property rowData.
     */
    component?: any;
    /**
     * The content of the expand button.
     * This can be HTML or even SVG - see the sanitizer property.
     */
    buttonContent?: string;
    hiddenWhen?: (row: Row) => boolean;
    disabledWhen?: (row: Row) => boolean;
    /**
     * Configures the sanitizer to allow HTML or SVG content in the button.
     */
    sanitizer?: SanitizerSettings;
}
interface IColumns {
    [key: string]: IColumn;
}
type IColumnType = 'text' | 'html' | 'custom';
type ISortDirection = 'asc' | 'desc' | null;
type RowClassFunction = (row: Row) => string;
type ColumnCompareFunction = (direction: number, left: any, right: any) => number;
type ValueCreateFunction = () => any;
type ColumnValuePrepareFunction = (rawValue: any, cell: Cell) => string;
type ColumnValueStoreFunction = (value: string, cell: Cell) => any;
type ColumnFilterFunction = (value: any, searchString: string) => boolean;
type ColumnComponentInitFunction = (component: any, cell: Cell) => void;
interface SanitizerSettings {
    /**
     * Set this to true to bypass the sanitizer for HTML content.
     * Security note: do not use this, if the content can be controlled by the user!
     */
    bypassHtml?: boolean;
}
interface TextEditorSettings {
    disableEnterKeySave?: boolean;
}
interface ListEditorSettings {
    disableEnterKeySave?: boolean;
    selectText?: string;
    list: {
        title: string;
        value: string;
    }[];
}
interface CheckboxEditorSettings {
    "true": string;
    "false": string;
}
interface ListFilterSettings {
    list: {
        title: string;
        value: string;
    }[];
    selectText?: string;
    strict?: boolean;
}
interface CheckboxFilterSettings {
    "true": string;
    "false": string;
    resetText: string;
}
interface EditorSettings {
    type: 'text' | 'textarea' | 'list' | 'checkbox' | 'custom';
    config?: TextEditorSettings | ListEditorSettings | CheckboxEditorSettings;
    component?: any;
}
interface FilterSettings {
    type: 'text' | 'list' | 'checkbox' | 'custom';
    config?: ListFilterSettings | CheckboxFilterSettings | unknown;
    component?: any;
}
interface IColumn {
    title?: string;
    type?: IColumnType;
    sanitizer?: SanitizerSettings;
    classHeader?: string;
    classContent?: string;
    class?: string;
    width?: string;
    sortDirection?: ISortDirection;
    editor?: EditorSettings;
    filter?: FilterSettings;
    renderComponent?: any;
    compareFunction?: ColumnCompareFunction;
    valuePrepareFunction?: ColumnValuePrepareFunction;
    valueStoreFunction?: ColumnValueStoreFunction;
    filterFunction?: ColumnFilterFunction;
    componentInitFunction?: ColumnComponentInitFunction;
    placeholder?: string;
    hide?: boolean;
    isSortable?: boolean;
    isEditable?: boolean;
    isAddable?: boolean;
    isFilterable?: boolean;
    isRowHeading?: boolean;
}
interface Attribute {
    id?: string;
    class?: string;
}
interface Actions {
    columnTitle?: string;
    add?: boolean;
    edit?: boolean;
    delete?: boolean;
    position?: 'left' | 'right';
    custom?: CustomAction[];
}
interface AddAction {
    inputClass?: string;
    sanitizer?: SanitizerSettings;
    hiddenWhen?: () => boolean;
    disabledWhen?: () => boolean;
    addButtonContent?: string;
    createButtonContent?: string;
    cancelButtonContent?: string;
    confirmCreate?: boolean;
}
interface EditAction {
    inputClass?: string;
    sanitizer?: SanitizerSettings;
    hiddenWhen?: (row: Row) => boolean;
    disabledWhen?: (row: Row) => boolean;
    editButtonContent?: string;
    saveButtonContent?: string;
    cancelButtonContent?: string;
    confirmSave?: boolean;
}
interface DeleteAction {
    sanitizer?: SanitizerSettings;
    hiddenWhen?: (row: Row) => boolean;
    disabledWhen?: (row: Row) => boolean;
    deleteButtonContent?: string;
    confirmDelete?: boolean;
}
interface Pager {
    page?: number;
    display?: boolean;
    perPage?: number;
    perPageSelect?: number[];
    perPageSelectLabel?: string;
}
interface CustomAction {
    name: string;
    title?: string;
    customButtonContent?: string;
    sanitizer?: SanitizerSettings;
    hiddenWhen?: (row: Row) => boolean;
    disabledWhen?: (row: Row) => boolean;
    renderComponent?: any;
}

declare class Column {
    id: string;
    protected settings: IColumn;
    protected dataSet: DataSet;
    placeholder?: string;
    title: string;
    hide: boolean;
    type: IColumnType;
    sanitizer: SanitizerSettings;
    classHeader: string;
    classContent: string;
    width: string;
    /**
     * If this column was resized, this contains the new width in pixels.
     * Please be aware that this only contains the width specified in the width
     * CSS attribute. It does NOT necessarily equal the actual width of the column
     * unless the table-layout is fixed.
     * Also note carefully that in automatic table layouts the actual width of other columns,
     * that are not adjacent to the resized column, may also change. Those changes are not
     * reflected by this property.
     */
    resizedWidth?: number;
    isSortable: boolean;
    isEditable: boolean;
    isAddable: boolean;
    isRowHeading: boolean;
    isFilterable: boolean;
    defaultSortDirection: ISortDirection;
    editor: EditorSettings;
    filter: FilterSettings;
    renderComponent?: any;
    compareFunction?: ColumnCompareFunction;
    valuePrepareFunction?: ColumnValuePrepareFunction;
    valueStoreFunction?: ColumnValueStoreFunction;
    filterFunction?: ColumnFilterFunction;
    componentInitFunction?: ColumnComponentInitFunction;
    constructor(id: string, settings: IColumn, dataSet: DataSet);
    getConfig(): any;
}

declare class Cell {
    protected value: unknown;
    protected row: Row;
    protected column: Column;
    private cachedValue;
    private cachedPreparedValue;
    private newValue;
    constructor(value: unknown, row: Row, column: Column);
    getColumn(): Column;
    getRow(): Row;
    /**
     * Gets the value (after post-processing with valuePrepareFunction).
     */
    getValue(): string;
    protected getPreparedValue(): string;
    /**
     * Returns the raw value that has not been post-processed by the valuePrepareFunction.
     */
    getRawValue(): unknown;
    setValue(value: string): void;
    /**
     * Returns the new raw value after being post-processed by the valueStoreFunction.
     */
    getNewRawValue(): any;
    getId(): string;
    getTitle(): string;
    isEditable(): boolean;
    resetValue(): void;
}

declare class Row {
    index: number;
    protected data: any;
    protected _dataSet: DataSet;
    isSelected: boolean;
    isInEditing: boolean;
    isExpanded: boolean;
    cells: Array<Cell>;
    constructor(index: number, data: any, _dataSet: DataSet);
    getCell(column: Column): Cell;
    getCells(): Cell[];
    getData(): any;
    getIsSelected(): boolean;
    getIsExpanded(): boolean;
    getNewData(): any;
    setData(data: any): any;
    process(): void;
}

declare class DataSet {
    protected columnSettings: IColumns;
    protected data: Array<Row>;
    protected columns: Array<Column>;
    protected rows: Array<Row>;
    protected selectedRow: Row | null;
    protected expandedRow?: Row;
    protected willSelect: 'first' | 'last' | 'indexed';
    constructor(data: Array<any> | undefined, columnSettings: IColumns);
    setData(data: Array<any>, selectedRows?: Array<any>): void;
    getColumns(): Array<Column>;
    getExpandedRow(): Row;
    getSelectedRow(): Row | null;
    getRows(): Array<Row>;
    getFirstRow(): Row;
    getLastRow(): Row;
    findRowByData(data: any): Row;
    deselectAll(): void;
    clearExpandAll(): void;
    selectRow(row: Row): void;
    multipleSelectRow(row: Row): void;
    expandRow(row: Row): Row;
    selectPreviousRow(): Row | null;
    selectFirstRow(): Row | null;
    selectLastRow(): Row | null;
    willSelectFirstRow(): void;
    willSelectLastRow(): void;
    select(index: number): Row | null;
    /**
     * Create columns by mapping from the settings
     * @param settings
     * @private
     */
    createColumns(settings: IColumns): void;
    /**
     * Create rows based on current data prepared in data source
     * @private
     */
    createRows(): void;
}

interface ISortConfig {
    field: string;
    direction: ISortDirection;
    compare?: ColumnCompareFunction;
}
interface IFilterConfig {
    field: string;
    search: string;
    filter?: ColumnFilterFunction;
}
interface IPagingConfig {
    page: number;
    perPage: number;
}
interface DataSourceChangeEvent {
    action: string;
    elements: any;
    paging: IPagingConfig;
    filter: IFilterConfig[];
    sort: ISortConfig[];
}
declare abstract class DataSource {
    protected onChangedSource: Subject<DataSourceChangeEvent>;
    protected onAddedSource: Subject<any>;
    protected onUpdatedSource: Subject<any>;
    protected onRemovedSource: Subject<any>;
    abstract getAll(): Promise<any>;
    abstract getElements(): Promise<any>;
    abstract getFilteredAndSorted(): Promise<any>;
    abstract getSort(): Array<ISortConfig>;
    abstract getFilter(): Array<IFilterConfig>;
    abstract getPaging(): IPagingConfig;
    /**
     * Returns the total number of elements with respect to the current filter.
     */
    abstract count(): number;
    abstract toggleItem(row: any, isSelected: boolean): void;
    /**
     * Sets the selection state of all (filtered) elements.
     * @param checked the new selection state
     * @param onlyFiltered only consider elements matching the current filter
     */
    abstract selectAllItems(checked: boolean, onlyFiltered: boolean): Promise<void>;
    abstract getSelectedItems(): Array<any>;
    /**
     * Indicates whether every (filtered) element is selected.
     *
     * @param onlyFiltered only consider elements matching the current filter
     * @param reportEmptyAsFalse by logic, in an empty set "all" elements are selected.
     * But if you want this to be reported as `false`, you can set this parameter to `true`.
     * @return true if all (filtered) elements are selected, false otherwise
     * @see selectAllItems
     */
    abstract isEveryElementSelected(onlyFiltered: boolean, reportEmptyAsFalse: boolean): boolean;
    refresh(): void;
    load(data: Array<any>): Promise<any>;
    onChanged(): Observable<DataSourceChangeEvent>;
    onAdded(): Observable<any>;
    onUpdated(): Observable<any>;
    onRemoved(): Observable<any>;
    prepend(element: any): Promise<any>;
    append(element: any): Promise<any>;
    add(element: any): Promise<any>;
    remove(element: any): Promise<any>;
    update(element: any, values: any): Promise<any>;
    empty(): Promise<any>;
    /**
     *
     * Array of conf objects
     * [
     *  {field: string, direction: asc|desc|null, compare?: ColumnCompareFunction|null},
     * ]
     * @param conf the configuration to add
     * @param doEmit indicates whether a sort event shall be emitted
     * @returns this data source
     */
    setSort(conf: Array<ISortConfig>, doEmit?: boolean): void;
    /**
     *
     * Array of conf objects
     * [
     *  {field: string, direction: asc|desc|null, compare?: ColumnCompareFunction|null},
     * ]
     * @param conf the configuration to add
     * @param doEmit indicates whether a sort event shall be emitted
     * @returns this data source
     */
    updateSort(conf: Array<ISortConfig>, doEmit?: boolean): void;
    setFilter(conf: Array<IFilterConfig>, doEmit?: boolean): void;
    addFilter(fieldConf: IFilterConfig, doEmit?: boolean): void;
    removeFilter(fieldName: string, doEmit?: boolean): void;
    setPaging(page: number, perPage: number, doEmit?: boolean): void;
    setPage(page: number, doEmit?: boolean): void;
    protected emitOnRemoved(element: any): void;
    protected emitOnUpdated(element: any): void;
    protected emitOnAdded(element: any): void;
    protected emitOnChanged(action: string): void;
}

declare class Deferred {
    promise: Promise<any>;
    resolve: any;
    reject: any;
    constructor();
}

interface CreateEvent {
    /**
     * The underlying data source.
     */
    source: DataSource;
}
interface CreateConfirmEvent extends CreateEvent {
    /**
     * The data that is supposed to be created.
     */
    newData: any;
    /**
     * A handle for resolving or rejecting the create event.
     */
    confirm: Deferred;
}
interface CreateCancelEvent {
    /**
     * The last state of editing before the operation was canceled.
     */
    discardedData: any;
    /**
     * The underlying data source.
     */
    source: DataSource;
}
interface EditEvent {
    /**
     * The row the edit operates on.
     */
    row: Row;
    /**
     * The row data (shortcut for row.getData()).
     */
    data: any;
    /**
     * The underlying data source.
     */
    source: DataSource;
}
interface EditConfirmEvent extends EditEvent {
    /**
     * The new data (shortcut for row.getNewData()).
     */
    newData: any;
    /**
     * A handle for resolving or rejecting the edit event.
     */
    confirm: Deferred;
}
interface EditCancelEvent {
    /**
     * The row the edit operates on.
     */
    row: Row;
    /**
     * The row data (shortcut for row.getData()).
     */
    data: any;
    /**
     * The last state of editing before the operation was canceled.
     */
    discardedData: any;
    /**
     * The underlying data source.
     */
    source: DataSource;
}
interface DeleteEvent {
    /**
     * The row that is supposed to be deleted.
     */
    row: Row;
    /**
     * The row data (shortcut for row.getData()).
     */
    data: any;
    /**
     * The underlying data source.
     */
    source: DataSource;
}
interface DeleteConfirmEvent extends DeleteEvent {
    /**
     * A handle for resolving or rejecting the delete event.
     */
    confirm: Deferred;
}
interface CustomActionEvent {
    /**
     * The named action for this event.
     */
    action: string;
    /**
     * The row this custom action operates on.
     */
    row: Row;
    /**
     * The row data (shortcut for row.getData()).
     */
    data: any;
    /**
     * The underlying data source.
     */
    source: DataSource;
}
interface RowSelectionEvent {
    /**
     * The row triggering the event (null if all rows are affected).
     */
    row: Row | null;
    /**
     * Convenience shortcut for row.getData().
     */
    data: any | null;
    /**
     Convenience shortcut for row.isSelected().
     */
    isSelected: boolean | null;
    /**
     * The data source of the table.
     */
    source: DataSource;
    /**
     * The new array of selected elements.
     */
    selected: any[];
}

declare class Grid {
    createFormShown: boolean;
    createFormRow: Row;
    source: DataSource;
    settings: Settings;
    dataSet: DataSet;
    /**
     * Points to an element in all data
     *
     * when < 0 all lines must be deselected
     */
    selectedRowIndex: number;
    onSelectRowSource: Subject<any>;
    private sourceOnChangedSubscription;
    private sourceOnUpdatedSubscription;
    constructor(source: DataSource, settings: Settings);
    detach(): void;
    showActionColumn(position: string): boolean;
    isMultiSelectVisible(): boolean;
    isMultiSortEnabled(): boolean;
    getExpandedRowComponentClass(): Type<any> | undefined;
    setSettings(settings: Settings): void;
    recreateDataSet(): void;
    getDataSet(): DataSet;
    setSource(source: DataSource): void;
    getColumns(): Array<Column>;
    getRows(): Array<Row>;
    selectRow(row: Row): void;
    multipleSelectRow(row: Row): void;
    onSelectRow(): Observable<any>;
    expandRow(row: Row): void;
    edit(row: Row): void;
    create(row: Row, confirmEmitter: EventEmitter<CreateConfirmEvent>): void;
    save(row: Row, confirmEmitter: EventEmitter<EditConfirmEvent>): void;
    delete(row: Row, confirmEmitter: EventEmitter<DeleteConfirmEvent>): void;
    processDataChange(changes: DataSourceChangeEvent): void;
    shouldProcessChange(changes: DataSourceChangeEvent): boolean;
    determineRowToSelect(changes: DataSourceChangeEvent): Row | null;
    prepareSource(source: DataSource): DataSource;
    getSelectedItems(): Array<any>;
    selectAllRows(status: boolean): Promise<void>;
    getFirstRow(): Row;
    getLastRow(): Row;
    private getSelectionInfo;
    private getRowIndexToSelect;
    private getPageToSelect;
    showCreateForm(): void;
}

interface TagsListEntry {
    key: string;
    value: string;
}
declare class TagComponent {
    item: TagsListEntry;
    close: EventEmitter<string>;
    closeClicked(evt: Event): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TagComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TagComponent, "angular2-smart-table-tag", never, { "item": { "alias": "item"; "required": false; }; }, { "close": "close"; }, never, never, false, never>;
}

declare class Angular2SmartTableComponent implements OnChanges, OnDestroy {
    source: any;
    settings: Settings;
    rowSelect: EventEmitter<RowSelectionEvent>;
    userRowSelect: EventEmitter<RowSelectionEvent>;
    delete: EventEmitter<DeleteEvent>;
    edit: EventEmitter<EditEvent>;
    create: EventEmitter<CreateEvent>;
    custom: EventEmitter<CustomActionEvent>;
    deleteConfirm: EventEmitter<DeleteConfirmEvent>;
    editConfirm: EventEmitter<EditConfirmEvent>;
    editCancel: EventEmitter<EditCancelEvent>;
    createConfirm: EventEmitter<CreateConfirmEvent>;
    createCancel: EventEmitter<CreateCancelEvent>;
    rowHover: EventEmitter<Row>;
    afterGridInit: EventEmitter<DataSet>;
    dataChangeSubscription?: Subscription;
    tableClass: string;
    tableId: string;
    perPageSelect: number[];
    perPageSelectLabel: string;
    isHideHeader: boolean;
    isHideSubHeader: boolean;
    isPagerDisplay: boolean;
    isTagListShown: boolean;
    rowClassFunction: RowClassFunction;
    grid: Grid;
    defaultSettings: Settings;
    isAllSelected: boolean;
    private onSelectRowSubscription;
    private destroyed$;
    ngOnChanges(changes: {
        [propertyName: string]: SimpleChange;
    }): void;
    ngOnDestroy(): void;
    onEditRowSelect(row: Row): void;
    onUserSelectRow(row: Row): void;
    onRowHover(row: Row): void;
    onMultipleSelectRow(row: Row): void;
    onSelectAllRows(): Promise<void>;
    onExpandRow(row: Row): void;
    prepareSource(): DataSource;
    processDataChange(_: DataSourceChangeEvent): void;
    prepareSettings(): Settings;
    getNotVisibleColumns(): Column[];
    notVisibleColumnTagsList: TagsListEntry[];
    updateNotVisibleColumnTagList(): void;
    onShowColumn(columnId: string): void;
    onHideColumn(columnId: string): void;
    private createRowSelectionEvent;
    private emitUserSelectRow;
    private emitSelectRow;
    private isIndexOutOfRange;
    private subscribeToOnSelectRow;
    static ɵfac: i0.ɵɵFactoryDeclaration<Angular2SmartTableComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<Angular2SmartTableComponent, "angular2-smart-table", never, { "source": { "alias": "source"; "required": false; }; "settings": { "alias": "settings"; "required": false; }; }, { "rowSelect": "rowSelect"; "userRowSelect": "userRowSelect"; "delete": "delete"; "edit": "edit"; "create": "create"; "custom": "custom"; "deleteConfirm": "deleteConfirm"; "editConfirm": "editConfirm"; "editCancel": "editCancel"; "createConfirm": "createConfirm"; "createCancel": "createCancel"; "rowHover": "rowHover"; "afterGridInit": "afterGridInit"; }, never, never, false, never>;
}

declare class CellComponent {
    grid: Grid;
    row: Row;
    cell: Cell;
    inputClass: string;
    mode: string;
    isInEditing: boolean;
    isNew: boolean;
    editConfirm: EventEmitter<EditConfirmEvent>;
    editCancel: EventEmitter<EditCancelEvent>;
    createConfirm: EventEmitter<CreateConfirmEvent>;
    createCancel: EventEmitter<CreateCancelEvent>;
    onEdited(): void;
    onStopEditing(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CellComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CellComponent, "angular2-smart-table-cell", never, { "grid": { "alias": "grid"; "required": false; }; "row": { "alias": "row"; "required": false; }; "cell": { "alias": "cell"; "required": false; }; "inputClass": { "alias": "inputClass"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "isInEditing": { "alias": "isInEditing"; "required": false; }; "isNew": { "alias": "isNew"; "required": false; }; "editConfirm": { "alias": "editConfirm"; "required": false; }; "editCancel": { "alias": "editCancel"; "required": false; }; "createConfirm": { "alias": "createConfirm"; "required": false; }; "createCancel": { "alias": "createCancel"; "required": false; }; }, {}, never, never, false, never>;
}

declare class EditCellDefault {
    cell: Cell;
    inputClass: string;
    edited: EventEmitter<void>;
    stopEditing: EventEmitter<void>;
    onEdited(): boolean;
    onStopEditing(): boolean;
    onClick(event: MouseEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<EditCellDefault, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<EditCellDefault, "ng-component", never, { "cell": { "alias": "cell"; "required": false; }; "inputClass": { "alias": "inputClass"; "required": false; }; }, { "edited": "edited"; "stopEditing": "stopEditing"; }, never, never, false, never>;
}

declare class DefaultEditor implements Editor {
    cell: Cell;
    inputClass: string;
    onStopEditing: EventEmitter<void>;
    onEdited: EventEmitter<void>;
    onClick: EventEmitter<MouseEvent>;
    get disableEnterKeySave(): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultEditor, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DefaultEditor, "ng-component", never, { "cell": { "alias": "cell"; "required": false; }; "inputClass": { "alias": "inputClass"; "required": false; }; }, { "onStopEditing": "onStopEditing"; "onEdited": "onEdited"; "onClick": "onClick"; }, never, never, false, never>;
}
interface Editor {
    cell: Cell;
    inputClass: string;
    onStopEditing: EventEmitter<void>;
    onEdited: EventEmitter<void>;
    onClick: EventEmitter<MouseEvent>;
}

declare class CustomEditComponent extends EditCellDefault implements OnChanges, OnDestroy {
    customComponent: any;
    dynamicTarget: ViewContainerRef;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CustomEditComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CustomEditComponent, "table-cell-custom-editor", never, {}, {}, never, never, false, never>;
}

declare class DefaultEditComponent extends EditCellDefault {
    constructor();
    getEditorType(): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultEditComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DefaultEditComponent, "table-cell-default-editor", never, {}, {}, never, never, false, never>;
}

declare class EditCellComponent implements OnInit {
    cell: Cell;
    inputClass: string;
    edited: EventEmitter<void>;
    stopEditing: EventEmitter<void>;
    ngOnInit(): void;
    getEditorType(): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<EditCellComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<EditCellComponent, "table-cell-edit-mode", never, { "cell": { "alias": "cell"; "required": false; }; "inputClass": { "alias": "inputClass"; "required": false; }; }, { "edited": "edited"; "stopEditing": "stopEditing"; }, never, never, false, never>;
}

declare class CheckboxEditorComponent extends DefaultEditor implements OnInit {
    trueVal: string;
    falseVal: string;
    constructor();
    ngOnInit(): void;
    onChange(newVal: boolean): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CheckboxEditorComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CheckboxEditorComponent, "checkbox-editor", never, {}, {}, never, never, false, never>;
}

declare class InputEditorComponent extends DefaultEditor {
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<InputEditorComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<InputEditorComponent, "input-editor", never, {}, {}, never, never, false, never>;
}

declare class SelectEditorComponent extends DefaultEditor {
    constructor();
    get editorConfig(): ListEditorSettings;
    onSelectionChanged(newValue: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<SelectEditorComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SelectEditorComponent, "select-editor", never, {}, {}, never, never, false, never>;
}

declare class TextareaEditorComponent extends DefaultEditor {
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<TextareaEditorComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TextareaEditorComponent, "textarea-editor", never, {}, {}, never, never, false, never>;
}

declare class CustomViewComponent implements OnInit, OnDestroy {
    customComponent: any;
    cell: Cell;
    dynamicTarget: ViewContainerRef;
    ngOnInit(): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CustomViewComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CustomViewComponent, "custom-view-component", never, { "cell": { "alias": "cell"; "required": false; }; }, {}, never, never, false, never>;
}

type SecurityTrustType = 'html' | 'style' | 'script' | 'url' | 'resourceUrl' | 'none';
declare class BypassSecurityTrustPipe implements PipeTransform {
    protected sanitizer: DomSanitizer;
    constructor(sanitizer: DomSanitizer);
    transform(value: string, type: SecurityTrustType): SafeHtml | SafeStyle | SafeScript | SafeUrl | SafeResourceUrl;
    static ɵfac: i0.ɵɵFactoryDeclaration<BypassSecurityTrustPipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<BypassSecurityTrustPipe, "bypassSecurityTrust", false>;
}

declare class ViewCellComponent {
    cell: Cell;
    get bypassSecurityTrust(): SecurityTrustType;
    get cssClass(): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<ViewCellComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ViewCellComponent, "table-cell-view-mode", never, { "cell": { "alias": "cell"; "required": false; }; }, {}, never, never, false, never>;
}

declare class PipesModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<PipesModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<PipesModule, [typeof BypassSecurityTrustPipe], never, [typeof BypassSecurityTrustPipe]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<PipesModule>;
}

declare class CellModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<CellModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<CellModule, [typeof CellComponent, typeof EditCellDefault, typeof DefaultEditor, typeof CustomEditComponent, typeof DefaultEditComponent, typeof EditCellComponent, typeof CheckboxEditorComponent, typeof InputEditorComponent, typeof SelectEditorComponent, typeof TextareaEditorComponent, typeof CustomViewComponent, typeof ViewCellComponent], [typeof i2.CommonModule, typeof PipesModule], [typeof CellComponent, typeof EditCellDefault, typeof DefaultEditor, typeof CustomEditComponent, typeof DefaultEditComponent, typeof EditCellComponent, typeof CheckboxEditorComponent, typeof InputEditorComponent, typeof SelectEditorComponent, typeof TextareaEditorComponent, typeof CustomViewComponent, typeof ViewCellComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<CellModule>;
}

declare class FilterDefault {
    column: Column;
    source: DataSource;
    inputClass: string;
    debounceTime: number;
    query: string;
    onFilter(query: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<FilterDefault, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<FilterDefault, "ng-component", never, { "column": { "alias": "column"; "required": false; }; "source": { "alias": "source"; "required": false; }; "inputClass": { "alias": "inputClass"; "required": false; }; "debounceTime": { "alias": "debounceTime"; "required": false; }; "query": { "alias": "query"; "required": false; }; }, {}, never, never, false, never>;
}

declare class DefaultFilter implements Filter, OnInit, OnDestroy {
    subject: Subject<string>;
    changesSubscription?: Subscription;
    query: string;
    inputClass: string;
    debounceTime: number;
    column: Column;
    filter: EventEmitter<string>;
    ngOnInit(): void;
    ngOnDestroy(): void;
    onValueChanged(value: string): void;
    setFilter(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultFilter, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DefaultFilter, "ng-component", never, { "query": { "alias": "query"; "required": false; }; "inputClass": { "alias": "inputClass"; "required": false; }; "debounceTime": { "alias": "debounceTime"; "required": false; }; "column": { "alias": "column"; "required": false; }; }, { "filter": "filter"; }, never, never, false, never>;
}
interface Filter {
    debounceTime: number;
    changesSubscription?: Subscription;
    query: string;
    inputClass: string;
    column: Column;
    filter: EventEmitter<string>;
}

declare class FilterComponent extends FilterDefault implements OnChanges {
    query: string;
    protected dataChangedSub: Subscription;
    ngOnChanges(changes: SimpleChanges): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<FilterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<FilterComponent, "angular2-smart-table-filter", never, {}, {}, never, never, false, never>;
}

declare class DefaultFilterComponent extends FilterDefault {
    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultFilterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DefaultFilterComponent, "default-table-filter", never, {}, {}, never, never, false, never>;
}

declare class CustomFilterComponent extends FilterDefault implements OnChanges, OnDestroy {
    customComponent: any;
    dynamicTarget: ViewContainerRef;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CustomFilterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CustomFilterComponent, "custom-table-filter", never, {}, {}, never, never, false, never>;
}

declare class CheckboxFilterComponent extends DefaultFilter implements OnInit {
    filterActive: boolean;
    checked: boolean;
    trueVal: string;
    falseVal: string;
    resetText: string;
    ngOnInit(): void;
    onChecked(checked: boolean): void;
    resetFilter(event: any): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CheckboxFilterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CheckboxFilterComponent, "checkbox-filter", never, {}, {}, never, never, false, never>;
}

declare class InputFilterComponent extends DefaultFilter {
    static ɵfac: i0.ɵɵFactoryDeclaration<InputFilterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<InputFilterComponent, "input-filter", never, {}, {}, never, never, false, never>;
}

declare class SelectFilterComponent extends DefaultFilter implements OnInit, OnDestroy {
    config: ListFilterSettings;
    ngOnInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<SelectFilterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SelectFilterComponent, "select-filter", never, {}, {}, never, never, false, never>;
}

declare class FilterModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<FilterModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<FilterModule, [typeof FilterDefault, typeof DefaultFilter, typeof FilterComponent, typeof DefaultFilterComponent, typeof CustomFilterComponent, typeof CheckboxFilterComponent, typeof InputFilterComponent, typeof SelectFilterComponent], [typeof i2.CommonModule], [typeof FilterDefault, typeof DefaultFilter, typeof FilterComponent, typeof DefaultFilterComponent, typeof CustomFilterComponent, typeof CheckboxFilterComponent, typeof InputFilterComponent, typeof SelectFilterComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<FilterModule>;
}

declare class PagerComponent implements OnChanges, OnDestroy {
    source: DataSource;
    perPageSelect: number[];
    perPageSelectLabel: string;
    protected pages: Array<any>;
    protected page: number;
    protected count: number;
    protected perPage: number;
    protected dataChangedSub: Subscription | null;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    shouldShow(): boolean;
    paginate(page: number): boolean;
    next(): boolean;
    prev(): boolean;
    getPage(): number;
    getPages(): Array<any>;
    getLast(): number;
    initPages(): void;
    onChangePerPage(newPerPage: number): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<PagerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<PagerComponent, "angular2-smart-table-pager", never, { "source": { "alias": "source"; "required": false; }; "perPageSelect": { "alias": "perPageSelect"; "required": false; }; "perPageSelectLabel": { "alias": "perPageSelectLabel"; "required": false; }; }, {}, never, never, false, never>;
}

declare class PagerModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<PagerModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<PagerModule, [typeof PagerComponent], [typeof i2.CommonModule], [typeof PagerComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<PagerModule>;
}

declare class TbodySaveCancelComponent implements OnChanges {
    grid: Grid;
    row: Row;
    editConfirm: EventEmitter<EditConfirmEvent>;
    editCancel: EventEmitter<EditCancelEvent>;
    cancelButtonContent: string;
    saveButtonContent: string;
    bypassSecurityTrust: SecurityTrustType;
    onSave(event: MouseEvent): void;
    onCancelEdit(event: MouseEvent): void;
    ngOnChanges(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TbodySaveCancelComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TbodySaveCancelComponent, "angular2-st-tbody-create-cancel", never, { "grid": { "alias": "grid"; "required": false; }; "row": { "alias": "row"; "required": false; }; "editConfirm": { "alias": "editConfirm"; "required": false; }; "editCancel": { "alias": "editCancel"; "required": false; }; }, {}, never, never, false, never>;
}

declare class TbodyEditDeleteComponent implements OnChanges {
    grid: Grid;
    row: Row;
    source: DataSource;
    deleteConfirm: EventEmitter<DeleteConfirmEvent>;
    edit: EventEmitter<EditEvent>;
    delete: EventEmitter<DeleteEvent>;
    editRowSelect: EventEmitter<any>;
    editRowButtonContent: string;
    editButtonBypassSecurityTrust: SecurityTrustType;
    editHiddenWhenFunction: (row: Row) => boolean;
    editDisabledWhenFunction: (row: Row) => boolean;
    deleteHiddenWhenFunction: (row: Row) => boolean;
    deleteDisabledWhenFunction: (row: Row) => boolean;
    deleteRowButtonContent: string;
    deleteButtonBypassSecurityTrust: SecurityTrustType;
    onEdit(event: any): void;
    onDelete(event: any): void;
    get editVisible(): boolean;
    get editDisabled(): boolean;
    get deleteVisible(): boolean;
    get deleteDisabled(): boolean;
    ngOnChanges(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TbodyEditDeleteComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TbodyEditDeleteComponent, "angular2-st-tbody-edit-delete", never, { "grid": { "alias": "grid"; "required": false; }; "row": { "alias": "row"; "required": false; }; "source": { "alias": "source"; "required": false; }; "deleteConfirm": { "alias": "deleteConfirm"; "required": false; }; }, { "edit": "edit"; "delete": "delete"; "editRowSelect": "editRowSelect"; }, never, never, false, never>;
}

declare class TbodyCustomComponent {
    grid: Grid;
    row: Row;
    source: any;
    custom: EventEmitter<CustomActionEvent>;
    get customActions(): CustomAction[];
    buttonContent(action: CustomAction): string;
    bypassSecurityTrustFor(action: CustomAction): SecurityTrustType;
    showAction(action: CustomAction): boolean;
    disableAction(action: CustomAction): boolean;
    onCustom(action: CustomAction, event: MouseEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TbodyCustomComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TbodyCustomComponent, "angular2-st-tbody-custom", never, { "grid": { "alias": "grid"; "required": false; }; "row": { "alias": "row"; "required": false; }; "source": { "alias": "source"; "required": false; }; }, { "custom": "custom"; }, never, never, false, never>;
}

declare class TbodyExpandRowComponent implements OnChanges {
    grid: Grid;
    row: Row;
    onExpandRow: EventEmitter<any>;
    buttonContent: string;
    bypassSecurityTrust: SecurityTrustType;
    hiddenWhenFunction: (row: Row) => boolean;
    disabledWhenFunction: (row: Row) => boolean;
    constructor();
    get visible(): boolean;
    get disabled(): boolean;
    onExpand(event: any): void;
    ngOnChanges(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TbodyExpandRowComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TbodyExpandRowComponent, "angular2-st-tbody-expand", never, { "grid": { "alias": "grid"; "required": false; }; "row": { "alias": "row"; "required": false; }; }, { "onExpandRow": "onExpandRow"; }, never, never, false, never>;
}

declare class TbodyCustomItemComponent implements OnInit, OnDestroy {
    customComponent: any;
    action: CustomAction;
    row: Row;
    dynamicTarget: ViewContainerRef;
    ngOnInit(): void;
    ngOnDestroy(): void;
    protected getPatch(): {
        action: CustomAction;
        rowData: any;
    };
    static ɵfac: i0.ɵɵFactoryDeclaration<TbodyCustomItemComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TbodyCustomItemComponent, "angular2-st-tbody-custom-item", never, { "action": { "alias": "action"; "required": false; }; "row": { "alias": "row"; "required": false; }; }, {}, never, never, false, never>;
}

declare class NgxSmartTableTbodyComponent implements AfterViewInit, OnChanges, OnDestroy {
    grid: Grid;
    source: DataSource;
    deleteConfirm: EventEmitter<DeleteConfirmEvent>;
    editConfirm: EventEmitter<EditConfirmEvent>;
    editCancel: EventEmitter<EditCancelEvent>;
    rowClassFunction: RowClassFunction;
    edit: EventEmitter<EditEvent>;
    delete: EventEmitter<DeleteEvent>;
    custom: EventEmitter<CustomActionEvent>;
    userSelectRow: EventEmitter<Row>;
    editRowSelect: EventEmitter<Row>;
    multipleSelectRow: EventEmitter<Row>;
    rowHover: EventEmitter<Row>;
    onExpandRow: EventEmitter<Row>;
    expandedRowChild: QueryList<ViewContainerRef>;
    expandedRowComponent: any;
    hasChildComponent: boolean;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    private createExpandedRowComponent;
    isMultiSelectVisible: boolean;
    showActionColumnLeft: boolean;
    showActionColumnRight: boolean;
    mode: string;
    editInputClass: string;
    noDataMessage: string;
    get tableColumnsCount(): number;
    ngOnChanges(): void;
    getVisibleCells(cells: Array<Cell>): Array<Cell>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxSmartTableTbodyComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NgxSmartTableTbodyComponent, "[angular2-st-tbody]", never, { "grid": { "alias": "grid"; "required": false; }; "source": { "alias": "source"; "required": false; }; "deleteConfirm": { "alias": "deleteConfirm"; "required": false; }; "editConfirm": { "alias": "editConfirm"; "required": false; }; "editCancel": { "alias": "editCancel"; "required": false; }; "rowClassFunction": { "alias": "rowClassFunction"; "required": false; }; }, { "edit": "edit"; "delete": "delete"; "custom": "custom"; "userSelectRow": "userSelectRow"; "editRowSelect": "editRowSelect"; "multipleSelectRow": "multipleSelectRow"; "rowHover": "rowHover"; "onExpandRow": "onExpandRow"; }, never, never, false, never>;
}

declare class TBodyModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<TBodyModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<TBodyModule, [typeof TbodySaveCancelComponent, typeof TbodyEditDeleteComponent, typeof TbodyCustomComponent, typeof TbodyExpandRowComponent, typeof TbodyCustomItemComponent, typeof NgxSmartTableTbodyComponent], [typeof i2.CommonModule, typeof CellModule, typeof PipesModule], [typeof TbodySaveCancelComponent, typeof TbodyEditDeleteComponent, typeof TbodyCustomComponent, typeof TbodyExpandRowComponent, typeof TbodyCustomItemComponent, typeof NgxSmartTableTbodyComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<TBodyModule>;
}

declare class TheadCreateCancelComponent implements OnChanges {
    grid: Grid;
    createConfirm: EventEmitter<CreateConfirmEvent>;
    createCancel: EventEmitter<CreateCancelEvent>;
    createButtonContent: string;
    cancelButtonContent: string;
    bypassSecurityTrust: SecurityTrustType;
    onCreate(event: MouseEvent): void;
    onCancelCreate(event: MouseEvent): void;
    ngOnChanges(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TheadCreateCancelComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TheadCreateCancelComponent, "angular2-st-actions", never, { "grid": { "alias": "grid"; "required": false; }; "createConfirm": { "alias": "createConfirm"; "required": false; }; "createCancel": { "alias": "createCancel"; "required": false; }; }, {}, never, never, false, never>;
}

declare class ActionsTitleComponent implements AfterViewInit, OnChanges {
    private ref;
    grid: Grid;
    actionsColumnTitle: string;
    constructor(ref: ElementRef);
    ngAfterViewInit(): void;
    ngOnChanges(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ActionsTitleComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ActionsTitleComponent, "[angular2-st-actions-title]", never, { "grid": { "alias": "grid"; "required": false; }; }, {}, never, never, false, never>;
}

declare class AddButtonComponent implements AfterViewInit, OnChanges {
    private ref;
    grid: Grid;
    source: DataSource;
    create: EventEmitter<CreateEvent>;
    hiddenWhenFunction: () => boolean;
    disabledWhenFunction: () => boolean;
    addNewButtonContent: string;
    bypassSecurityTrust: SecurityTrustType;
    constructor(ref: ElementRef);
    ngAfterViewInit(): void;
    get visible(): boolean;
    get disabled(): boolean;
    ngOnChanges(): void;
    onAdd(event: any): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AddButtonComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AddButtonComponent, "[angular2-st-add-button]", never, { "grid": { "alias": "grid"; "required": false; }; "source": { "alias": "source"; "required": false; }; }, { "create": "create"; }, never, never, false, never>;
}

declare class ColumnTitleComponent implements OnChanges, OnDestroy {
    currentDirection: 'asc' | 'desc' | null;
    multiSort: boolean;
    column: Column;
    source: DataSource;
    isHideable: boolean;
    hide: EventEmitter<string>;
    protected dataChangedSub: Subscription | null;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    _sort(event: any): void;
    _hideColumnClicked(event: any): void;
    private changeSortDirection;
    static ɵfac: i0.ɵɵFactoryDeclaration<ColumnTitleComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ColumnTitleComponent, "angular2-st-column-title", never, { "multiSort": { "alias": "multiSort"; "required": false; }; "column": { "alias": "column"; "required": false; }; "source": { "alias": "source"; "required": false; }; "isHideable": { "alias": "isHideable"; "required": false; }; }, { "hide": "hide"; }, never, never, false, never>;
}

declare class TheadFitlersRowComponent implements OnChanges {
    grid: Grid;
    source: DataSource;
    create: EventEmitter<CreateEvent>;
    isMultiSelectVisible: boolean;
    showActionColumnLeft: boolean;
    showActionColumnRight: boolean;
    filterInputClass: string;
    filterDebounceTime: number;
    ngOnChanges(changes: SimpleChanges): void;
    getVisibleColumns(columns: Array<Column>): Array<Column>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TheadFitlersRowComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TheadFitlersRowComponent, "[angular2-st-thead-filters-row]", never, { "grid": { "alias": "grid"; "required": false; }; "source": { "alias": "source"; "required": false; }; }, { "create": "create"; }, never, never, false, never>;
}

declare class TheadFormRowComponent implements OnChanges {
    grid: Grid;
    row: Row;
    createConfirm: EventEmitter<CreateConfirmEvent>;
    createCancel: EventEmitter<CreateCancelEvent>;
    isMultiSelectVisible: boolean;
    showActionColumnLeft: boolean;
    showActionColumnRight: boolean;
    addInputClass: string;
    ngOnChanges(): void;
    getVisibleCells(cells: Array<Cell>): Array<Cell>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TheadFormRowComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TheadFormRowComponent, "[angular2-st-thead-form-row]", never, { "grid": { "alias": "grid"; "required": false; }; "row": { "alias": "row"; "required": false; }; "createConfirm": { "alias": "createConfirm"; "required": false; }; "createCancel": { "alias": "createCancel"; "required": false; }; }, {}, never, never, false, never>;
}

declare class TheadTitlesRowComponent implements OnChanges {
    grid: Grid;
    isAllSelected: boolean;
    source: DataSource;
    hide: EventEmitter<string>;
    selectAllRows: EventEmitter<void>;
    multiSelectWidth: string;
    isMultiSelectVisible: boolean;
    showActionColumnLeft: boolean;
    showActionColumnRight: boolean;
    isResizable: boolean;
    isHideable: boolean;
    ngOnChanges(): void;
    get visibleColumns(): Array<Column>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TheadTitlesRowComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TheadTitlesRowComponent, "[angular2-st-thead-titles-row]", never, { "grid": { "alias": "grid"; "required": false; }; "isAllSelected": { "alias": "isAllSelected"; "required": false; }; "source": { "alias": "source"; "required": false; }; }, { "hide": "hide"; "selectAllRows": "selectAllRows"; }, never, never, false, never>;
}

declare class TableService {
    mouseMoveEvent$: Subject<MouseEvent>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TableService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TableService>;
}

declare class NgxSmartTableTheadComponent implements OnChanges {
    private tableService;
    grid: Grid;
    source: DataSource;
    isAllSelected: boolean;
    createConfirm: EventEmitter<CreateConfirmEvent>;
    createCancel: EventEmitter<CreateCancelEvent>;
    hide: EventEmitter<string>;
    selectAllRows: EventEmitter<void>;
    create: EventEmitter<CreateEvent>;
    isHideHeader: boolean;
    isHideSubHeader: boolean;
    constructor(tableService: TableService);
    ngOnChanges(): void;
    mouseMove(event: MouseEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxSmartTableTheadComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NgxSmartTableTheadComponent, "[angular2-st-thead]", never, { "grid": { "alias": "grid"; "required": false; }; "source": { "alias": "source"; "required": false; }; "isAllSelected": { "alias": "isAllSelected"; "required": false; }; "createConfirm": { "alias": "createConfirm"; "required": false; }; "createCancel": { "alias": "createCancel"; "required": false; }; }, { "hide": "hide"; "selectAllRows": "selectAllRows"; "create": "create"; }, never, never, false, never>;
}

declare class NgxResizerDirective implements OnInit, OnDestroy {
    private elementRef;
    private renderer;
    private tableService;
    angular2SmartTableResizer: {
        column: Column;
        siblingColumn: Column | undefined;
    };
    isClicked: boolean;
    parentElement: any;
    siblingElement: any;
    pointerOffset: number;
    parentOffset: number;
    siblingOffset: number | undefined;
    destroyed$: Subject<any>;
    constructor(elementRef: ElementRef, renderer: Renderer2, tableService: TableService);
    ngOnInit(): void;
    onMouseEnter(event: MouseEvent): void;
    onMouseDown(): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxResizerDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgxResizerDirective, "[angular2SmartTableResizer]", never, { "angular2SmartTableResizer": { "alias": "angular2SmartTableResizer"; "required": false; }; }, {}, never, never, false, never>;
}

declare class DirectivesModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<DirectivesModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<DirectivesModule, [typeof NgxResizerDirective], [typeof i2.CommonModule], [typeof NgxResizerDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<DirectivesModule>;
}

declare class THeadModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<THeadModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<THeadModule, [typeof TheadCreateCancelComponent, typeof ActionsTitleComponent, typeof AddButtonComponent, typeof ColumnTitleComponent, typeof TheadFitlersRowComponent, typeof TheadFormRowComponent, typeof TheadTitlesRowComponent, typeof NgxSmartTableTheadComponent], [typeof i2.CommonModule, typeof FilterModule, typeof CellModule, typeof DirectivesModule, typeof PipesModule], [typeof TheadCreateCancelComponent, typeof ActionsTitleComponent, typeof AddButtonComponent, typeof ColumnTitleComponent, typeof TheadFitlersRowComponent, typeof TheadFormRowComponent, typeof TheadTitlesRowComponent, typeof NgxSmartTableTheadComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<THeadModule>;
}

declare class TagsListComponent {
    tags: TagsListEntry[];
    close: EventEmitter<string>;
    closedTag(tagKey: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TagsListComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TagsListComponent, "angular2-smart-table-tags-list", never, { "tags": { "alias": "tags"; "required": false; }; }, { "close": "close"; }, never, never, false, never>;
}

declare class TagsModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<TagsModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<TagsModule, [typeof TagComponent, typeof TagsListComponent], [typeof i2.CommonModule], [typeof TagComponent, typeof TagsListComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<TagsModule>;
}

declare class Angular2SmartTableModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<Angular2SmartTableModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<Angular2SmartTableModule, [typeof Angular2SmartTableComponent], [typeof i2.CommonModule, typeof CellModule, typeof FilterModule, typeof PagerModule, typeof TBodyModule, typeof THeadModule, typeof TagsModule], [typeof Angular2SmartTableComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<Angular2SmartTableModule>;
}

declare class LocalDataSource extends DataSource {
    protected data: Array<any>;
    protected filteredAndSorted: Array<any>;
    protected sortConf: Array<ISortConfig>;
    protected filterConf: Array<IFilterConfig>;
    protected pagingConf: IPagingConfig;
    private selectedItems;
    constructor(data?: Array<any>);
    load(data: Array<any>): Promise<any>;
    prepend(element: any): Promise<any>;
    append(element: any): Promise<any>;
    add(element: any): Promise<any>;
    remove(element: any): Promise<any>;
    update(element: any, values: any): Promise<any>;
    find(element: any): Promise<any>;
    getElements(): Promise<any>;
    getFilteredAndSorted(): Promise<any>;
    getAll(): Promise<any>;
    reset(silent?: boolean): void;
    empty(): Promise<any>;
    count(): number;
    toggleItem(row: any, isSelected: boolean): void;
    selectAllItems(checked: boolean, onlyFiltered?: boolean): Promise<void>;
    isEveryElementSelected(onlyFiltered?: boolean, reportEmptyAsFalse?: boolean): boolean;
    getSelectedItems(): Array<any>;
    setSort(conf: Array<ISortConfig>, doEmit?: boolean): void;
    updateSort(conf: Array<ISortConfig>, doEmit?: boolean): void;
    /**
     *
     * Replaces all filters with the given array of filters.
     * [
     *  {field: string, search: string, filter: ColumnCompareFunction|null},
     * ]
     *
     * @param conf the array of filters
     * @param doEmit true if an event shall be emitted that triggers a table refresh
     */
    setFilter(conf: Array<IFilterConfig>, doEmit?: boolean): void;
    /**
     *
     * Adds a filter to this data source.
     *
     * {field: string, search: string, filter: ColumnFilterFunction|null},
     *
     * @param fieldConf the filter config
     * @param doEmit true if an event shall be emitted that triggers a table refresh
     */
    addFilter(fieldConf: IFilterConfig, doEmit?: boolean): void;
    removeFilter(fieldName: string, doEmit?: boolean): void;
    setPaging(page: number, perPage: number, doEmit?: boolean): void;
    setPage(page: number, doEmit?: boolean): void;
    getSort(): Array<ISortConfig>;
    getFilter(): Array<IFilterConfig>;
    getPaging(): IPagingConfig;
    protected prepareData(data: Array<any>): Array<any>;
    protected sort(data: Array<any>): Array<any>;
    protected filter(data: Array<any>): Array<any>;
    protected paginate(data: Array<any>): Array<any>;
}

declare class ServerSourceConf {
    protected static readonly SORT_FIELD_KEY = "_sort";
    protected static readonly SORT_DIR_KEY = "_order";
    protected static readonly PAGER_PAGE_KEY = "_page";
    protected static readonly PAGER_LIMIT_KEY = "_limit";
    protected static readonly FILTER_FIELD_KEY = "#field#_like";
    protected static readonly TOTAL_KEY = "x-total-count";
    protected static readonly DATA_KEY = "";
    endPoint: string;
    sortFieldKey: string;
    sortDirKey: string;
    pagerPageKey: string;
    pagerLimitKey: string;
    filterFieldKey: string;
    totalKey: string;
    dataKey: string;
    constructor({ endPoint, sortFieldKey, sortDirKey, pagerPageKey, pagerLimitKey, filterFieldKey, totalKey, dataKey }?: {
        endPoint?: string | undefined;
        sortFieldKey?: string | undefined;
        sortDirKey?: string | undefined;
        pagerPageKey?: string | undefined;
        pagerLimitKey?: string | undefined;
        filterFieldKey?: string | undefined;
        totalKey?: string | undefined;
        dataKey?: string | undefined;
    });
}

declare class ServerDataSource extends LocalDataSource {
    protected http: HttpClient;
    protected conf: ServerSourceConf;
    protected lastRequestCount: number;
    constructor(http: HttpClient, conf?: ServerSourceConf | {});
    count(): number;
    getAll(): Promise<any>;
    getElements(): Promise<any>;
    getFilteredAndSorted(): Promise<any>;
    protected loadData(filtered: boolean, sorted: boolean, paginated: boolean): Promise<any>;
    /**
     * Extracts array of data from server response
     * @param res
     * @returns {any}
     */
    protected extractDataFromResponse(res: any): Array<any>;
    /**
     * Extracts total rows count from the server response
     * Looks for the count in the headers first, then in the response body
     * @param res
     * @returns {any}
     */
    protected extractTotalFromResponse(res: any): number;
    protected requestElements(filtered: boolean, sorted: boolean, paginated: boolean): Observable<any>;
    protected addSortRequestParams(httpParams: HttpParams): HttpParams;
    protected addFilterRequestParams(httpParams: HttpParams): HttpParams;
    protected addPagerRequestParams(httpParams: HttpParams): HttpParams;
}

export { Angular2SmartTableComponent, Angular2SmartTableModule, Cell, Column, DataSet, DataSource, DefaultEditor, DefaultFilter, LocalDataSource, Row, ServerDataSource };
export type { Actions, AddAction, Attribute, CheckboxEditorSettings, CheckboxFilterSettings, ColumnCompareFunction, ColumnComponentInitFunction, ColumnFilterFunction, ColumnValuePrepareFunction, ColumnValueStoreFunction, CreateCancelEvent, CreateConfirmEvent, CreateEvent, CustomAction, CustomActionEvent, DataSourceChangeEvent, DeleteAction, DeleteConfirmEvent, DeleteEvent, EditAction, EditCancelEvent, EditConfirmEvent, EditEvent, Editor, EditorSettings, Expand, Filter, FilterSettings, IColumn, IColumnType, IColumns, IFilterConfig, IPagingConfig, ISortConfig, ISortDirection, ListEditorSettings, ListFilterSettings, Pager, RowClassFunction, RowSelectionEvent, SanitizerSettings, Settings, TextEditorSettings, ValueCreateFunction };
