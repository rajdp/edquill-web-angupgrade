import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Input, Component, EventEmitter, Output, ViewContainerRef, ViewChild, Pipe, ChangeDetectionStrategy, ViewChildren, Injectable, HostListener, Directive, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { delay, distinctUntilChanged, debounceTime, takeUntil, filter, map } from 'rxjs/operators';
import { cloneDeep } from 'lodash-es';
import * as i1$1 from '@angular/platform-browser';
import { HttpParams } from '@angular/common/http';

class DataSource {
    onChangedSource = new Subject();
    onAddedSource = new Subject();
    onUpdatedSource = new Subject();
    onRemovedSource = new Subject();
    refresh() {
        this.emitOnChanged('refresh');
    }
    load(data) {
        this.emitOnChanged('load');
        return Promise.resolve();
    }
    onChanged() {
        return this.onChangedSource.asObservable();
    }
    onAdded() {
        return this.onAddedSource.asObservable();
    }
    onUpdated() {
        return this.onUpdatedSource.asObservable();
    }
    onRemoved() {
        return this.onRemovedSource.asObservable();
    }
    prepend(element) {
        this.emitOnAdded(element);
        this.emitOnChanged('prepend');
        return Promise.resolve();
    }
    append(element) {
        this.emitOnAdded(element);
        this.emitOnChanged('append');
        return Promise.resolve();
    }
    add(element) {
        this.emitOnAdded(element);
        this.emitOnChanged('add');
        return Promise.resolve();
    }
    remove(element) {
        this.emitOnRemoved(element);
        this.emitOnChanged('remove');
        return Promise.resolve();
    }
    update(element, values) {
        this.emitOnUpdated(element);
        this.emitOnChanged('update');
        return Promise.resolve();
    }
    empty() {
        this.emitOnChanged('empty');
        return Promise.resolve();
    }
    /**
     *
     * Array of conf objects
     * [
     *  {field: string, direction: asc|desc|null, compare?: ColumnCompareFunction|null},
     * ]
     * @param conf the configuration to add
     * @param doEmit indicates whether a sort event shall be emitted
     * @returns this data source
     */
    setSort(conf, doEmit) {
        if (doEmit) {
            this.emitOnChanged('sort');
        }
    }
    /**
     *
     * Array of conf objects
     * [
     *  {field: string, direction: asc|desc|null, compare?: ColumnCompareFunction|null},
     * ]
     * @param conf the configuration to add
     * @param doEmit indicates whether a sort event shall be emitted
     * @returns this data source
     */
    updateSort(conf, doEmit) {
        if (doEmit) {
            this.emitOnChanged('sort');
        }
    }
    setFilter(conf, doEmit) {
        if (doEmit) {
            this.emitOnChanged('filter');
        }
    }
    addFilter(fieldConf, doEmit) {
        if (doEmit) {
            this.emitOnChanged('filter');
        }
    }
    removeFilter(fieldName, doEmit) {
        if (doEmit) {
            this.emitOnChanged('filter');
        }
    }
    setPaging(page, perPage, doEmit) {
        if (doEmit) {
            this.emitOnChanged('paging');
        }
    }
    setPage(page, doEmit) {
        if (doEmit) {
            this.emitOnChanged('page');
        }
    }
    emitOnRemoved(element) {
        this.onRemovedSource.next(element);
    }
    emitOnUpdated(element) {
        this.onUpdatedSource.next(element);
    }
    emitOnAdded(element) {
        this.onAddedSource.next(element);
    }
    emitOnChanged(action) {
        this.getElements().then((elements) => this.onChangedSource.next({
            action: action,
            elements: elements,
            paging: this.getPaging(),
            filter: this.getFilter(),
            sort: this.getSort(),
        }));
    }
}

function defaultObjectComparator(direction, left, right) {
    if (left == null && right == null) {
        return 0;
    }
    // only one of them can be null now
    if (left == null || left < right) {
        return -1 * direction;
    }
    if (right == null || right < left) {
        return direction;
    }
    // none of them can be null now, and they must be equal
    return 0;
}
function defaultNumberComparator(direction, left, right) {
    // the default comparator already does what we want, so this function is merely a type-safe alias
    return defaultObjectComparator(direction, left, right);
}
function defaultStringComparator(direction, left, right) {
    if (left == null && right == null) {
        return 0;
    }
    else if (left == null) {
        return -1 * direction;
    }
    else if (right == null) {
        return direction;
    }
    else {
        return left.localeCompare(right) * direction;
    }
}
/**
 * Compares two values with special treatment for numbers and strings.
 *
 * The rule is: if both values are of type number (or null), they are compared as if they were numbers.
 * If both values are either null, undefined or typeof string, they are compared as strings using the current locale.
 * Otherwise, they are compared using their natural ordering.
 *
 * Null values are considered less than any non-null element. Null and undefined are considered equal.
 *
 * @param direction 1 for ascending and -1 for descending (other values are not allowed)
 * @param left the left value
 * @param right the right value
 */
function defaultComparator(direction, left, right) {
    const leftIsNumeric = left == null || (!isNaN(parseFloat(left)) && !isNaN(left - 0));
    const rightIsNumeric = right == null || (!isNaN(parseFloat(right)) && !isNaN(right - 0));
    const leftIsString = left == null || (typeof left === 'string');
    const rightIsString = right == null || (typeof right === 'string');
    if (leftIsNumeric && rightIsNumeric) {
        return defaultNumberComparator(direction, Number(left), Number(right));
    }
    else if (leftIsString && rightIsString) {
        return defaultStringComparator(direction, left, right);
    }
    else {
        return defaultObjectComparator(direction, left, right);
    }
}

class LocalPager {
    static paginate(data, page, perPage) {
        return data.slice(perPage * (page - 1), perPage * page);
    }
}

/**
 * Extending object that entered in first argument.
 *
 * Returns extended object or false if have no target object or incorrect type.
 *
 * If you wish to clone source object (without modify it), just use empty new
 * object as first argument, like this:
 *   deepExtend({}, yourObj_1, [yourObj_N]);
 */
const deepExtend = function (...objects) {
    if (arguments.length < 1 || typeof arguments[0] !== 'object') {
        return false;
    }
    if (arguments.length < 2) {
        return arguments[0];
    }
    const target = arguments[0];
    // convert arguments to array and cut off target object
    const args = Array.prototype.slice.call(arguments, 1);
    let val, src;
    args.forEach((obj) => {
        // skip argument if it is array or isn't object
        if (typeof obj !== 'object' || Array.isArray(obj)) {
            return;
        }
        Object.keys(obj).forEach(function (key) {
            src = target[key]; // source value
            val = obj[key]; // new value
            // recursion prevention
            if (val === target) {
                return;
                /**
                 * if new value isn't object then just overwrite by new value
                 * instead of extending.
                 */
            }
            else if (typeof val !== 'object' || val === null) {
                target[key] = val;
                return;
                // just clone arrays (and recursive clone objects inside)
            }
            else if (Array.isArray(val)) {
                target[key] = cloneDeep(val);
                return;
                // overwrite by new value if source isn't object or array
            }
            else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
                target[key] = deepExtend({}, val);
                return;
                // source value and new value is objects both, extending...
            }
            else {
                target[key] = deepExtend(src, val);
                return;
            }
        });
    });
    return target;
};
class Deferred {
    promise;
    resolve;
    reject;
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}
// getDeepFromObject({result: {data: 1}}, 'result.data', 2); // returns 1
function getDeepFromObject(object = {}, name, defaultValue) {
    const keys = name.split('.');
    // clone the object
    let level = deepExtend({}, object);
    keys.forEach((k) => {
        if (typeof level !== 'undefined') {
            level = level[k];
        }
    });
    return typeof level === 'undefined' ? defaultValue : level;
}
function getPageForRowIndex(index, perPage) {
    // we need to add 1 to convert 0-based index to 1-based page number.
    return Math.floor(index / perPage) + 1;
}

class LocalDataSource extends DataSource {
    data = [];
    filteredAndSorted = [];
    sortConf = [];
    filterConf = [];
    pagingConf = { page: 1, perPage: 10 };
    selectedItems = [];
    constructor(data = []) {
        super();
        this.data = data;
    }
    load(data) {
        this.data = data;
        return super.load(data);
    }
    prepend(element) {
        this.reset(true);
        this.data.unshift(element);
        return super.prepend(element);
    }
    append(element) {
        this.reset(true);
        this.data.push(element);
        return super.append(element);
    }
    add(element) {
        this.data.push(element);
        return super.add(element);
    }
    remove(element) {
        this.data = this.data.filter(el => el !== element);
        return super.remove(element);
    }
    update(element, values) {
        return new Promise((resolve, reject) => {
            this.find(element).then((found) => {
                found = deepExtend(found, values);
                super.update(found, values).then(resolve).catch(reject);
            }).catch(reject);
        });
    }
    find(element) {
        const found = this.data.find(el => el === element);
        if (found) {
            return Promise.resolve(found);
        }
        return Promise.reject(new Error('Element was not found in the dataset'));
    }
    getElements() {
        const data = this.data.slice(0);
        return Promise.resolve(this.prepareData(data));
    }
    getFilteredAndSorted() {
        let data = this.data.slice(0);
        this.prepareData(data); // this would return only the current page, but it sets filteredAndSorted array
        return Promise.resolve(this.filteredAndSorted);
    }
    getAll() {
        const data = this.data.slice(0);
        return Promise.resolve(data);
    }
    reset(silent = false) {
        this.setFilter([], false);
        this.setSort([], false);
        this.setPage(1, !silent);
    }
    empty() {
        this.data = [];
        return super.empty();
    }
    count() {
        return this.filteredAndSorted.length;
    }
    toggleItem(row, isSelected) {
        if (isSelected)
            this.selectedItems.push(row);
        else
            this.selectedItems = this.selectedItems.filter((i) => i !== row);
    }
    // TODO: actually there is no need that this is an async function, but changing the signature would be a breaking change
    async selectAllItems(checked, onlyFiltered = false) {
        if (checked) {
            const itemsToSelect = onlyFiltered ? this.filteredAndSorted : this.data;
            this.selectedItems = itemsToSelect.slice(0);
        }
        else
            this.selectedItems = [];
    }
    isEveryElementSelected(onlyFiltered = false, reportEmptyAsFalse = false) {
        const itemsToCheck = onlyFiltered ? this.filteredAndSorted : this.data;
        if (itemsToCheck.length === 0) {
            return !reportEmptyAsFalse;
        }
        if (onlyFiltered) {
            // TODO: this is an ugly and costly O(n²) check, but currently we have no other choice....
            if (itemsToCheck.length !== this.selectedItems.length)
                return false;
            for (const item of itemsToCheck) {
                if (this.selectedItems.indexOf(itemsToCheck) < 0)
                    return false;
            }
            return true;
        }
        else {
            return itemsToCheck.length === this.selectedItems.length;
        }
    }
    getSelectedItems() {
        return this.selectedItems;
    }
    setSort(conf, doEmit = true) {
        this.sortConf = conf;
        super.setSort(conf, doEmit);
    }
    updateSort(conf, doEmit = true) {
        if (conf !== null) {
            conf.forEach((fieldConf) => {
                const found = this.sortConf.findIndex(c => c.field === fieldConf.field);
                if (found >= 0) {
                    if (fieldConf.compare === undefined) {
                        // keep the previously configured compare function
                        fieldConf.compare = this.sortConf[found].compare;
                    }
                    this.sortConf.splice(found, 1);
                }
                // push the updated config to the front of the array (highest sort priority)
                this.sortConf = [fieldConf, ...this.sortConf];
            });
        }
        super.setSort(conf, doEmit);
    }
    /**
     *
     * Replaces all filters with the given array of filters.
     * [
     *  {field: string, search: string, filter: ColumnCompareFunction|null},
     * ]
     *
     * @param conf the array of filters
     * @param doEmit true if an event shall be emitted that triggers a table refresh
     */
    setFilter(conf, doEmit = true) {
        this.filterConf = conf;
        super.setFilter(conf, doEmit);
    }
    /**
     *
     * Adds a filter to this data source.
     *
     * {field: string, search: string, filter: ColumnFilterFunction|null},
     *
     * @param fieldConf the filter config
     * @param doEmit true if an event shall be emitted that triggers a table refresh
     */
    addFilter(fieldConf, doEmit = true) {
        let found = false;
        this.filterConf.forEach((currentFieldConf, index) => {
            if (currentFieldConf.field === fieldConf.field) {
                this.filterConf[index] = fieldConf;
                found = true;
            }
        });
        if (!found) {
            this.filterConf.push(fieldConf);
        }
        super.addFilter(fieldConf, doEmit);
    }
    removeFilter(fieldName, doEmit = true) {
        this.filterConf = this.filterConf.filter(c => c.field !== fieldName);
        super.removeFilter(fieldName, doEmit);
    }
    setPaging(page, perPage, doEmit = true) {
        this.pagingConf.page = page;
        this.pagingConf.perPage = perPage;
        super.setPaging(page, perPage, doEmit);
    }
    setPage(page, doEmit = true) {
        this.pagingConf.page = page;
        super.setPage(page, doEmit);
    }
    getSort() {
        return this.sortConf;
    }
    getFilter() {
        return this.filterConf;
    }
    getPaging() {
        return this.pagingConf;
    }
    prepareData(data) {
        data = this.filter(data);
        data = this.sort(data);
        this.filteredAndSorted = data.slice(0);
        return this.paginate(data);
    }
    sort(data) {
        // only use the part of the config where sorting is enabled
        const sortConfig = this.sortConf.filter(c => c.direction !== null);
        return data.sort((a, b) => {
            for (const sc of sortConfig) {
                const dir = (sc.direction === 'asc') ? 1 : -1;
                const compare = sc.compare ? sc.compare : defaultComparator;
                let parts = sc.field.split(".");
                let propA = a;
                for (let i = 0; i < parts.length && typeof propA !== 'undefined'; i++) {
                    propA = propA[parts[i]];
                }
                let propB = b;
                for (let i = 0; i < parts.length && typeof propB !== 'undefined'; i++) {
                    propB = propB[parts[i]];
                }
                const result = compare.call(null, dir, propA, propB);
                if (result !== 0)
                    return result;
            }
            return 0;
        });
    }
    filter(data) {
        if (this.filterConf) {
            for (const filterConf of this.filterConf) {
                const filter = filterConf.filter ?? ((v, s) => (v?.toString() ?? '').toLowerCase().includes(s.toLowerCase()));
                data = data.filter((el) => {
                    let parts = filterConf.field.split(".");
                    let prop = el;
                    for (let i = 0; i < parts.length && typeof prop !== 'undefined'; i++) {
                        prop = prop[parts[i]];
                    }
                    return filter.call(null, prop, filterConf.search);
                });
            }
        }
        return data;
    }
    paginate(data) {
        return LocalPager.paginate(data, this.pagingConf.page, this.pagingConf.perPage);
    }
}

class Cell {
    value;
    row;
    column;
    cachedValue;
    cachedPreparedValue = '';
    newValue;
    constructor(value, row, column) {
        this.value = value;
        this.row = row;
        this.column = column;
        this.resetValue();
    }
    getColumn() {
        return this.column;
    }
    getRow() {
        return this.row;
    }
    /**
     * Gets the value (after post-processing with valuePrepareFunction).
     */
    getValue() {
        if (this.cachedValue !== this.value) {
            this.cachedPreparedValue = this.getPreparedValue();
            this.cachedValue = this.value;
        }
        return this.cachedPreparedValue;
    }
    getPreparedValue() {
        try {
            const prepare = this.column.valuePrepareFunction ?? ((v) => (v?.toString() ?? ''));
            return prepare.call(null, this.value, this);
        }
        catch (_) {
            console.error(`The valuePrepareFunction of column ${this.column.id} threw an error. Using simple toString() as fallback.`);
            console.error('Please check the implementation of valuePrepareFunction.');
            console.error('If this error was raised when creating a new row, please also check the implementation of valueCreateFunction.');
            return this.value?.toString() ?? '';
        }
    }
    /**
     * Returns the raw value that has not been post-processed by the valuePrepareFunction.
     */
    getRawValue() {
        return this.value;
    }
    setValue(value) {
        const store = this.column.valueStoreFunction ?? ((v) => v);
        this.newValue = store.call(null, value, this);
    }
    /**
     * Returns the new raw value after being post-processed by the valueStoreFunction.
     */
    getNewRawValue() {
        return this.newValue;
    }
    getId() {
        return this.getColumn().id;
    }
    getTitle() {
        return this.getColumn().title;
    }
    isEditable() {
        if (this.getRow().index === -1) {
            return this.getColumn().isAddable ?? false;
        }
        else {
            return this.getColumn().isEditable ?? false;
        }
    }
    resetValue() {
        this.cachedValue = this.value;
        this.newValue = this.value;
        this.cachedPreparedValue = this.getPreparedValue();
    }
}

class Row {
    index;
    data;
    _dataSet;
    isSelected = false;
    isInEditing = false;
    isExpanded = false;
    cells = [];
    constructor(index, data, _dataSet) {
        this.index = index;
        this.data = data;
        this._dataSet = _dataSet;
        this.process();
    }
    getCell(column) {
        const theCell = this.cells.find(el => el.getColumn() === column);
        if (!theCell)
            throw new Error('There is no cell with such Column');
        return theCell;
    }
    getCells() {
        return this.cells;
    }
    getData() {
        return this.data;
    }
    getIsSelected() {
        return this.isSelected;
    }
    getIsExpanded() {
        return this.isExpanded;
    }
    getNewData() {
        const values = Object.assign({}, this.data);
        this.getCells().forEach((cell) => values[cell.getColumn().id] = cell.getNewRawValue());
        return values;
    }
    setData(data) {
        this.data = data;
        this.process();
    }
    process() {
        this.cells = [];
        this._dataSet.getColumns().forEach((column) => {
            this.cells.push(new Cell(this.data[column.id], this, column));
        });
    }
}

class Column {
    id;
    settings;
    dataSet;
    placeholder;
    title;
    hide;
    type;
    sanitizer;
    classHeader;
    classContent;
    width;
    /**
     * If this column was resized, this contains the new width in pixels.
     * Please be aware that this only contains the width specified in the width
     * CSS attribute. It does NOT necessarily equal the actual width of the column
     * unless the table-layout is fixed.
     * Also note carefully that in automatic table layouts the actual width of other columns,
     * that are not adjacent to the resized column, may also change. Those changes are not
     * reflected by this property.
     */
    resizedWidth = undefined;
    isSortable;
    isEditable;
    isAddable;
    isRowHeading;
    isFilterable;
    defaultSortDirection;
    editor;
    filter;
    renderComponent;
    compareFunction;
    valuePrepareFunction;
    valueStoreFunction;
    filterFunction;
    componentInitFunction;
    constructor(id, settings, dataSet) {
        this.id = id;
        this.settings = settings;
        this.dataSet = dataSet;
        this.type = this.settings.type ?? 'text';
        this.placeholder = this.settings.placeholder;
        this.sanitizer = this.settings.sanitizer ?? {};
        this.title = this.settings.title ?? '';
        this.classHeader = this.settings.classHeader ?? '';
        this.classContent = this.settings.classContent ?? '';
        this.width = this.settings.width ?? 'auto';
        this.hide = this.settings.hide ?? false;
        this.editor = this.settings.editor ?? { type: 'text' };
        this.filter = this.settings.filter ?? { type: 'text' };
        this.renderComponent = this.settings.renderComponent;
        this.isFilterable = this.settings.isFilterable ?? true;
        this.isSortable = this.settings.isSortable ?? true;
        this.isEditable = this.settings.isEditable ?? true;
        this.isAddable = this.settings.isAddable ?? true;
        this.isRowHeading = this.settings.isRowHeading ?? false;
        this.defaultSortDirection = this.settings.sortDirection ?? null;
        this.compareFunction = this.settings.compareFunction;
        this.valuePrepareFunction = this.settings.valuePrepareFunction;
        this.valueStoreFunction = this.settings.valueStoreFunction;
        this.filterFunction = this.settings.filterFunction;
        this.componentInitFunction = this.settings.componentInitFunction;
    }
    getConfig() {
        return this.editor && this.editor.config;
    }
}

class DataSet {
    columnSettings;
    data = [];
    columns = [];
    rows = [];
    selectedRow = null;
    expandedRow;
    willSelect = 'indexed';
    constructor(data = [], columnSettings) {
        this.columnSettings = columnSettings;
        this.createColumns(columnSettings);
        this.setData(data);
    }
    setData(data, selectedRows = []) {
        this.data = data.map((el, index) => {
            const row = new Row(index, el, this);
            row.isSelected = selectedRows.indexOf(el) > -1;
            return row;
        });
        this.createRows();
    }
    getColumns() {
        return this.columns;
    }
    getExpandedRow() {
        if (!this.expandedRow) {
            console.warn('Expanded row not found');
            throw new Error('Expanded row not found');
        }
        return this.expandedRow;
    }
    getSelectedRow() {
        return this.selectedRow;
    }
    getRows() {
        return this.rows ?? [];
    }
    getFirstRow() {
        return this.rows[0];
    }
    getLastRow() {
        return this.rows[this.rows.length - 1];
    }
    findRowByData(data) {
        const row = this.rows.find((row) => row.getData() === data);
        if (!row) {
            console.warn('Data row not found', data);
            throw new Error('Row not found');
        }
        return row;
    }
    deselectAll() {
        this.rows.forEach((row) => {
            row.isSelected = false;
        });
        // we need to clear selectedRow field because no one row selected
        this.selectedRow = null;
    }
    clearExpandAll() {
        this.rows.forEach((row) => {
            row.isExpanded = false;
        });
        // we need to clear selectedRow field because no one row selected
        this.expandedRow = undefined;
    }
    selectRow(row) {
        const previousIsSelected = row.isSelected;
        this.deselectAll();
        row.isSelected = !previousIsSelected;
        this.selectedRow = row;
    }
    multipleSelectRow(row) {
        row.isSelected = !row.isSelected;
        this.selectedRow = row;
    }
    expandRow(row) {
        const previousIsExpanded = row.isExpanded;
        this.clearExpandAll();
        if (row.index !== this.expandedRow?.index) {
            this.expandedRow = undefined;
        }
        row.isExpanded = !previousIsExpanded;
        this.expandedRow = row;
        return this.expandedRow;
    }
    selectPreviousRow() {
        if (this.rows.length > 0) {
            let index = this.selectedRow ? this.selectedRow.index : 0;
            if (index > this.rows.length - 1) {
                index = this.rows.length - 1;
            }
            this.selectRow(this.rows[index]);
            return this.getSelectedRow();
        }
        else {
            return null;
        }
    }
    selectFirstRow() {
        if (this.rows.length > 0) {
            this.selectRow(this.rows[0]);
            return this.getSelectedRow();
        }
        else {
            return null;
        }
    }
    selectLastRow() {
        if (this.rows.length > 0) {
            this.selectRow(this.rows[this.rows.length - 1]);
            return this.getSelectedRow();
        }
        else {
            return null;
        }
    }
    willSelectFirstRow() {
        this.willSelect = 'first';
    }
    willSelectLastRow() {
        this.willSelect = 'last';
    }
    select(index) {
        if (index >= 0 && this.getRows().length === 0) {
            return null;
        }
        const willSelect = this.willSelect;
        this.willSelect = 'indexed';
        if (willSelect === 'indexed') {
            if (index >= 0 && index < this.rows.length) {
                this.selectRow(this.rows[index]);
                return this.selectedRow;
            }
            else {
                // we need to deselect all rows if we got an incorrect index
                this.deselectAll();
                return null;
            }
        }
        else if (willSelect === 'first') {
            return this.selectFirstRow();
        }
        else if (willSelect === 'last') {
            return this.selectLastRow();
        }
        else {
            // this branch is unreachable, because the if-else is exhaustive, but stupid typescript compilers do not see that
            return null;
        }
    }
    /**
     * Create columns by mapping from the settings
     * @param settings
     * @private
     */
    createColumns(settings) {
        for (const id in settings) {
            if (settings.hasOwnProperty(id)) {
                this.columns.push(new Column(id, settings[id], this));
            }
        }
    }
    /**
     * Create rows based on current data prepared in data source
     * @private
     */
    createRows() {
        this.rows = [];
        this.data.forEach((el) => {
            this.rows.push(el);
        });
    }
}

class Grid {
    createFormShown = false;
    createFormRow;
    source;
    settings;
    dataSet;
    /**
     * Points to an element in all data
     *
     * when < 0 all lines must be deselected
     */
    selectedRowIndex = -1;
    onSelectRowSource = new Subject();
    sourceOnChangedSubscription;
    sourceOnUpdatedSubscription;
    constructor(source, settings) {
        this.setSettings(settings);
        this.setSource(source);
    }
    detach() {
        if (this.sourceOnChangedSubscription) {
            this.sourceOnChangedSubscription.unsubscribe();
        }
        if (this.sourceOnUpdatedSubscription) {
            this.sourceOnUpdatedSubscription.unsubscribe();
        }
    }
    showActionColumn(position) {
        // no actions configured, therefore now actions visible
        if (this.settings.actions === false || this.settings.actions === undefined) {
            return false;
        }
        // not the correct position
        if (position !== this.settings.actions?.position) {
            return false;
        }
        // column is visible if and only if at least one action is visible - check all of them
        return this.settings.actions.add || this.settings.actions.edit || this.settings.actions.delete ||
            (this.settings.actions.custom?.length ?? 0) > 0 ||
            this.getExpandedRowComponentClass() !== undefined;
    }
    isMultiSelectVisible() {
        return this.settings.selectMode === 'multi' || this.settings.selectMode === 'multi_filtered';
    }
    isMultiSortEnabled() {
        return this.settings.sortMode !== 'single';
    }
    getExpandedRowComponentClass() {
        return this.settings.expand?.component;
    }
    setSettings(settings) {
        this.settings = settings;
        this.recreateDataSet();
    }
    recreateDataSet() {
        this.dataSet = new DataSet([], this.settings.columns);
        if (this.source) {
            this.source.refresh();
        }
    }
    getDataSet() {
        return this.dataSet;
    }
    setSource(source) {
        this.detach();
        this.source = this.prepareSource(source);
        this.sourceOnChangedSubscription = this.source.onChanged().subscribe((changes) => this.processDataChange(changes));
        this.sourceOnUpdatedSubscription = this.source.onUpdated().subscribe((data) => {
            const changedRow = this.dataSet.findRowByData(data);
            changedRow.setData(data);
        });
    }
    getColumns() {
        return this.dataSet.getColumns();
    }
    getRows() {
        return this.dataSet.getRows();
    }
    selectRow(row) {
        this.dataSet.selectRow(row);
        this.source.toggleItem(row.getData(), row.isSelected);
    }
    multipleSelectRow(row) {
        this.dataSet.multipleSelectRow(row);
        this.source.toggleItem(row.getData(), row.isSelected);
    }
    onSelectRow() {
        return this.onSelectRowSource.asObservable();
    }
    expandRow(row) {
        this.dataSet.expandRow(row);
    }
    edit(row) {
        row.isInEditing = true;
    }
    create(row, confirmEmitter) {
        const deferred = new Deferred();
        deferred.promise.then((newData) => {
            newData = newData ? newData : row.getNewData();
            this.createFormShown = false;
            this.source.prepend(newData).then();
        }).catch((err) => {
            // doing nothing
        });
        if (this.settings.add?.confirmCreate ?? false) {
            confirmEmitter.emit({
                newData: row.getNewData(),
                source: this.source,
                confirm: deferred,
            });
        }
        else {
            deferred.resolve();
        }
    }
    save(row, confirmEmitter) {
        const deferred = new Deferred();
        deferred.promise.then((newData) => {
            newData = newData ? newData : row.getNewData();
            if (deferred.resolve.skipEdit) {
                row.isInEditing = false;
            }
            else {
                this.source.update(row.getData(), newData).then(() => {
                    row.isInEditing = false;
                });
            }
        }).catch((err) => {
            // doing nothing
        });
        if (this.settings.edit?.confirmSave ?? false) {
            confirmEmitter.emit({
                row: row,
                data: row.getData(),
                newData: row.getNewData(),
                source: this.source,
                confirm: deferred,
            });
        }
        else {
            deferred.resolve();
        }
    }
    delete(row, confirmEmitter) {
        const deferred = new Deferred();
        deferred.promise.then(() => {
            this.source.remove(row.getData());
        }).catch((err) => {
            // doing nothing
        });
        if (this.settings.delete?.confirmDelete ?? false) {
            confirmEmitter.emit({
                row: row,
                data: row.getData(),
                source: this.source,
                confirm: deferred,
            });
        }
        else {
            deferred.resolve();
        }
    }
    processDataChange(changes) {
        if (this.shouldProcessChange(changes)) {
            this.dataSet.setData(changes.elements, this.getSelectedItems());
            if (this.settings.selectMode === 'single') {
                if (this.dataSet.getRows().length > 0) {
                    const row = this.determineRowToSelect(changes);
                    this.onSelectRowSource.next(row);
                }
                else {
                    this.onSelectRowSource.next(null);
                }
            }
        }
    }
    shouldProcessChange(changes) {
        if (['filter', 'sort', 'page', 'remove', 'refresh', 'load', 'empty', 'paging'].indexOf(changes.action) !== -1) {
            return true;
        }
        else if (['prepend', 'append'].indexOf(changes.action) !== -1 && (this.settings.pager?.display ?? true)) {
            return true;
        }
        return false;
    }
    determineRowToSelect(changes) {
        if (['load', 'page', 'filter', 'sort', 'refresh'].indexOf(changes.action) !== -1) {
            return this.dataSet.select(this.getRowIndexToSelect());
        }
        if (this.selectedRowIndex < 0) {
            return null;
        }
        if (changes.action === 'remove') {
            if (changes.elements.length === 0) {
                // we have to store which one to select as the data will be reloaded
                this.dataSet.willSelectLastRow();
            }
            else {
                return this.dataSet.selectPreviousRow();
            }
        }
        if (changes.action === 'append') {
            // we have to store which one to select as the data will be reloaded
            this.dataSet.willSelectLastRow();
        }
        if (changes.action === 'add') {
            return this.dataSet.selectFirstRow();
        }
        if (changes.action === 'update') {
            return this.dataSet.selectFirstRow();
        }
        if (changes.action === 'prepend') {
            // we have to store which one to select as the data will be reloaded
            this.dataSet.willSelectFirstRow();
        }
        return null;
    }
    prepareSource(source) {
        let sortConf = [];
        for (const column of this.getColumns()) {
            if (column.isSortable && column.defaultSortDirection !== null) {
                sortConf.push({
                    field: column.id,
                    direction: column.defaultSortDirection,
                    compare: column.compareFunction,
                });
            }
        }
        source.setSort(sortConf, false);
        source.setPaging(this.getPageToSelect(source), this.settings.pager?.perPage ?? 10, false);
        source.refresh();
        return source;
    }
    getSelectedItems() {
        return this.source.getSelectedItems();
    }
    async selectAllRows(status) {
        // remember that the data set of the grid only contains the visible elements on the current page
        this.dataSet.getRows().forEach(r => r.isSelected = status);
        // advise the data source to also update the selected elements
        await this.source.selectAllItems(status, this.settings.selectMode === 'multi_filtered');
    }
    getFirstRow() {
        return this.dataSet.getFirstRow();
    }
    getLastRow() {
        return this.dataSet.getLastRow();
    }
    getSelectionInfo() {
        return {
            perPage: this.settings.pager?.perPage ?? 10,
            page: this.settings.pager?.page ?? 1,
            selectedRowIndex: this.selectedRowIndex,
            switchPageToSelectedRowPage: this.settings.switchPageToSelectedRowPage ?? false,
        };
    }
    getRowIndexToSelect() {
        const { switchPageToSelectedRowPage, selectedRowIndex, perPage } = this.getSelectionInfo();
        const dataAmount = this.source.count();
        /**
         * source - contains all table data
         * dataSet - contains data for current page
         * selectedRowIndex - contains index for data in all data
         *
         * because of that, we need to count index for a specific row in page
         * if
         * `switchPageToSelectedRowPage` - we need to change page automatically
         * `selectedRowIndex < dataAmount && selectedRowIndex >= 0` - index points to existing data
         * (if index points to non-existing data and we calculate index for current page - we will get wrong selected row.
         *  if we return index witch not points to existing data - no line will be highlighted)
         */
        return (switchPageToSelectedRowPage &&
            selectedRowIndex < dataAmount &&
            selectedRowIndex >= 0) ?
            selectedRowIndex % perPage :
            selectedRowIndex;
    }
    getPageToSelect(source) {
        const { switchPageToSelectedRowPage, selectedRowIndex, perPage, page } = this.getSelectionInfo();
        let pageToSelect = Math.max(1, page);
        if (switchPageToSelectedRowPage && selectedRowIndex >= 0) {
            pageToSelect = getPageForRowIndex(selectedRowIndex, perPage);
        }
        const maxPageAmount = Math.ceil(source.count() / perPage);
        return maxPageAmount ? Math.min(pageToSelect, maxPageAmount) : pageToSelect;
    }
    showCreateForm() {
        // if already shown, do nothing
        if (this.createFormShown)
            return;
        const vcf = this.settings.valueCreateFunction ?? (() => ({}));
        this.createFormRow = new Row(-1, vcf(), this.dataSet);
        this.createFormRow.isInEditing = true;
        this.createFormShown = true;
    }
}

class PagerComponent {
    source;
    perPageSelect;
    perPageSelectLabel;
    pages;
    page;
    count = 0;
    perPage;
    dataChangedSub = null;
    ngOnChanges(changes) {
        if (changes.source) {
            if (this.dataChangedSub !== null) {
                this.dataChangedSub.unsubscribe();
            }
            this.dataChangedSub = this.source.onChanged().subscribe((dataChanges) => {
                this.page = this.source.getPaging().page;
                this.perPage = this.source.getPaging().perPage;
                this.count = this.source.count();
                const lastPage = this.getLast();
                if (dataChanges.action === 'prepend') {
                    this.source.setPage(1);
                }
                else if (dataChanges.action === 'append') {
                    this.source.setPage(lastPage);
                }
                else if (this.page > lastPage) {
                    this.source.setPage(lastPage);
                }
                else if (this.page < 1) {
                    // for whatever reason...
                    this.source.setPage(1);
                }
                else {
                    // do not execute the following function when we needed to adjust the page!
                    // another event will be emitted and as a reaction we will end up here again
                    // (in previous versions, this code was executed unnecessarily often)
                    this.initPages();
                }
            });
        }
    }
    ngOnDestroy() {
        if (this.dataChangedSub !== null) {
            this.dataChangedSub.unsubscribe();
            this.dataChangedSub = null;
        }
    }
    shouldShow() {
        return this.source.count() > this.perPage;
    }
    paginate(page) {
        this.source.setPage(page);
        this.page = page;
        return false;
    }
    next() {
        return this.paginate(this.getPage() + 1);
    }
    prev() {
        return this.paginate(this.getPage() - 1);
    }
    getPage() {
        return this.page;
    }
    getPages() {
        return this.pages;
    }
    getLast() {
        const last = Math.ceil(this.count / this.perPage);
        return last === 0 ? 1 : last;
    }
    initPages() {
        const pagesCount = this.getLast();
        let showPagesCount = 4;
        showPagesCount = pagesCount < showPagesCount ? pagesCount : showPagesCount;
        this.pages = [];
        if (this.shouldShow()) {
            let middleOne = Math.ceil(showPagesCount / 2);
            middleOne = this.page >= middleOne ? this.page : middleOne;
            let lastOne = middleOne + Math.floor(showPagesCount / 2);
            lastOne = lastOne >= pagesCount ? pagesCount : lastOne;
            const firstOne = lastOne - showPagesCount + 1;
            for (let i = firstOne; i <= lastOne; i++) {
                this.pages.push(i);
            }
        }
    }
    onChangePerPage(newPerPage) {
        this.source.getPaging().perPage = newPerPage;
        this.source.refresh();
        this.initPages();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: PagerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: PagerComponent, isStandalone: false, selector: "angular2-smart-table-pager", inputs: { source: "source", perPageSelect: "perPageSelect", perPageSelectLabel: "perPageSelectLabel" }, usesOnChanges: true, ngImport: i0, template: `
    <nav *ngIf="shouldShow()" class="angular2-smart-pagination-nav">
      <ul class="angular2-smart-pagination pagination">
        <li class="angular2-smart-page-item page-item" [ngClass]="{disabled: getPage() == 1}">
          <a class="angular2-smart-page-link page-link" href="#"
          (click)="getPage() == 1 ? false : paginate(1)" aria-label="First">
            <span aria-hidden="true">&laquo;</span>
            <span class="sr-only">First</span>
          </a>
        </li>
        <li class="angular2-smart-page-item page-item" [ngClass]="{disabled: getPage() == 1}">
          <a class="angular2-smart-page-link page-link page-link-prev" href="#"
             (click)="getPage() == 1 ? false : prev()" aria-label="Prev">
            <span aria-hidden="true">&lt;</span>
            <span class="sr-only">Prev</span>
          </a>
        </li>
        <li class="angular2-smart-page-item page-item"
        [ngClass]="{active: getPage() == page}" *ngFor="let page of getPages()">
          <span class="angular2-smart-page-link page-link"
          *ngIf="getPage() == page">{{ page }} <span class="sr-only">(current)</span></span>
          <a class="angular2-smart-page-link page-link" href="#"
          (click)="paginate(page)" *ngIf="getPage() != page">{{ page }}</a>
        </li>

        <li class="angular2-smart-page-item page-item"
            [ngClass]="{disabled: getPage() == getLast()}">
          <a class="angular2-smart-page-link page-link page-link-next" href="#"
             (click)="getPage() == getLast() ? false : next()" aria-label="Next">
            <span aria-hidden="true">&gt;</span>
            <span class="sr-only">Next</span>
          </a>
        </li>

        <li class="angular2-smart-page-item page-item"
        [ngClass]="{disabled: getPage() == getLast()}">
          <a class="angular2-smart-page-link page-link" href="#"
          (click)="getPage() == getLast() ? false : paginate(getLast())" aria-label="Last">
            <span aria-hidden="true">&raquo;</span>
            <span class="sr-only">Last</span>
          </a>
        </li>
      </ul>
    </nav>
    <div *ngIf="!shouldShow()"><!-- placeholder to consume the space of the page selection --></div>

    <nav *ngIf="perPageSelect && perPageSelect.length > 0" class="angular2-smart-pagination-per-page">
      <label for="per-page" *ngIf="perPageSelectLabel">{{perPageSelectLabel}}</label>
      <select (change)="onChangePerPage($any($event.target).value)" [value]="perPage" id="per-page">
        <option *ngFor="let item of perPageSelect" [value]="item">{{ item }}</option>
      </select>
    </nav>
  `, isInline: true, styles: [".angular2-smart-pagination{display:inline-flex;font-size:.875em;padding:0}.angular2-smart-pagination .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.angular2-smart-pagination .angular2-smart-page-item{display:inline}.angular2-smart-pagination .page-link-next,.angular2-smart-pagination .page-link-prev{font-size:10px}:host{display:flex;justify-content:space-between}:host ul{margin:1rem 0}:host select{margin:1rem 0}:host label{margin:1rem 1rem 1rem 0;line-height:2.5rem}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: PagerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'angular2-smart-table-pager', template: `
    <nav *ngIf="shouldShow()" class="angular2-smart-pagination-nav">
      <ul class="angular2-smart-pagination pagination">
        <li class="angular2-smart-page-item page-item" [ngClass]="{disabled: getPage() == 1}">
          <a class="angular2-smart-page-link page-link" href="#"
          (click)="getPage() == 1 ? false : paginate(1)" aria-label="First">
            <span aria-hidden="true">&laquo;</span>
            <span class="sr-only">First</span>
          </a>
        </li>
        <li class="angular2-smart-page-item page-item" [ngClass]="{disabled: getPage() == 1}">
          <a class="angular2-smart-page-link page-link page-link-prev" href="#"
             (click)="getPage() == 1 ? false : prev()" aria-label="Prev">
            <span aria-hidden="true">&lt;</span>
            <span class="sr-only">Prev</span>
          </a>
        </li>
        <li class="angular2-smart-page-item page-item"
        [ngClass]="{active: getPage() == page}" *ngFor="let page of getPages()">
          <span class="angular2-smart-page-link page-link"
          *ngIf="getPage() == page">{{ page }} <span class="sr-only">(current)</span></span>
          <a class="angular2-smart-page-link page-link" href="#"
          (click)="paginate(page)" *ngIf="getPage() != page">{{ page }}</a>
        </li>

        <li class="angular2-smart-page-item page-item"
            [ngClass]="{disabled: getPage() == getLast()}">
          <a class="angular2-smart-page-link page-link page-link-next" href="#"
             (click)="getPage() == getLast() ? false : next()" aria-label="Next">
            <span aria-hidden="true">&gt;</span>
            <span class="sr-only">Next</span>
          </a>
        </li>

        <li class="angular2-smart-page-item page-item"
        [ngClass]="{disabled: getPage() == getLast()}">
          <a class="angular2-smart-page-link page-link" href="#"
          (click)="getPage() == getLast() ? false : paginate(getLast())" aria-label="Last">
            <span aria-hidden="true">&raquo;</span>
            <span class="sr-only">Last</span>
          </a>
        </li>
      </ul>
    </nav>
    <div *ngIf="!shouldShow()"><!-- placeholder to consume the space of the page selection --></div>

    <nav *ngIf="perPageSelect && perPageSelect.length > 0" class="angular2-smart-pagination-per-page">
      <label for="per-page" *ngIf="perPageSelectLabel">{{perPageSelectLabel}}</label>
      <select (change)="onChangePerPage($any($event.target).value)" [value]="perPage" id="per-page">
        <option *ngFor="let item of perPageSelect" [value]="item">{{ item }}</option>
      </select>
    </nav>
  `, standalone: false, styles: [".angular2-smart-pagination{display:inline-flex;font-size:.875em;padding:0}.angular2-smart-pagination .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.angular2-smart-pagination .angular2-smart-page-item{display:inline}.angular2-smart-pagination .page-link-next,.angular2-smart-pagination .page-link-prev{font-size:10px}:host{display:flex;justify-content:space-between}:host ul{margin:1rem 0}:host select{margin:1rem 0}:host label{margin:1rem 1rem 1rem 0;line-height:2.5rem}\n"] }]
        }], propDecorators: { source: [{
                type: Input
            }], perPageSelect: [{
                type: Input
            }], perPageSelectLabel: [{
                type: Input
            }] } });

class EditCellDefault {
    cell;
    inputClass = '';
    edited = new EventEmitter();
    stopEditing = new EventEmitter();
    onEdited() {
        this.edited.emit();
        return false;
    }
    onStopEditing() {
        this.stopEditing.emit();
        return false;
    }
    onClick(event) {
        event.stopPropagation();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: EditCellDefault, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: EditCellDefault, isStandalone: false, selector: "ng-component", inputs: { cell: "cell", inputClass: "inputClass" }, outputs: { edited: "edited", stopEditing: "stopEditing" }, ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: EditCellDefault, decorators: [{
            type: Component,
            args: [{
                    template: '',
                    standalone: false
                }]
        }], propDecorators: { cell: [{
                type: Input
            }], inputClass: [{
                type: Input
            }], edited: [{
                type: Output
            }], stopEditing: [{
                type: Output
            }] } });

class CustomEditComponent extends EditCellDefault {
    customComponent;
    dynamicTarget;
    ngOnChanges(changes) {
        if (this.cell && !this.customComponent) {
            const editor = this.cell.getColumn().editor;
            if (!editor)
                return;
            this.customComponent = this.dynamicTarget.createComponent(editor.component);
            // set @Inputs and @Outputs of custom component
            this.customComponent.instance.cell = this.cell;
            this.customComponent.instance.inputClass = this.inputClass;
            this.customComponent.instance.onStopEditing.subscribe(() => this.onStopEditing());
            this.customComponent.instance.onEdited.subscribe(() => this.onEdited());
            this.customComponent.instance.onClick.subscribe((event) => this.onClick(event));
        }
    }
    ngOnDestroy() {
        if (this.customComponent) {
            this.customComponent.destroy();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CustomEditComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: CustomEditComponent, isStandalone: false, selector: "table-cell-custom-editor", viewQueries: [{ propertyName: "dynamicTarget", first: true, predicate: ["dynamicTarget"], descendants: true, read: ViewContainerRef, static: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
    <ng-template #dynamicTarget></ng-template>
  `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CustomEditComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'table-cell-custom-editor',
                    template: `
    <ng-template #dynamicTarget></ng-template>
  `,
                    standalone: false
                }]
        }], propDecorators: { dynamicTarget: [{
                type: ViewChild,
                args: ['dynamicTarget', { read: ViewContainerRef, static: true }]
            }] } });

class DefaultEditor {
    cell;
    inputClass;
    onStopEditing = new EventEmitter();
    onEdited = new EventEmitter();
    onClick = new EventEmitter();
    get disableEnterKeySave() {
        return this.cell.getColumn().getConfig() && this.cell.getColumn().getConfig().disableEnterKeySave;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DefaultEditor, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: DefaultEditor, isStandalone: false, selector: "ng-component", inputs: { cell: "cell", inputClass: "inputClass" }, outputs: { onStopEditing: "onStopEditing", onEdited: "onEdited", onClick: "onClick" }, ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DefaultEditor, decorators: [{
            type: Component,
            args: [{
                    template: '',
                    standalone: false
                }]
        }], propDecorators: { cell: [{
                type: Input
            }], inputClass: [{
                type: Input
            }], onStopEditing: [{
                type: Output
            }], onEdited: [{
                type: Output
            }], onClick: [{
                type: Output
            }] } });

class CheckboxEditorComponent extends DefaultEditor {
    trueVal = 'true';
    falseVal = 'false';
    constructor() {
        super();
    }
    ngOnInit() {
        const config = this.cell.getColumn().editor.config;
        if (config !== undefined) {
            const ces = config;
            this.trueVal = ces.true;
            this.falseVal = ces.false;
        }
    }
    onChange(newVal) {
        this.cell.setValue(newVal ? this.trueVal : this.falseVal);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CheckboxEditorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: CheckboxEditorComponent, isStandalone: false, selector: "checkbox-editor", usesInheritance: true, ngImport: i0, template: `
    <input [ngClass]="inputClass"
           type="checkbox"
           [name]="cell.getId()"
           [disabled]="!cell.isEditable()"
           [checked]="cell.getValue() === trueVal"
           (click)="onClick.emit($event)"
           (change)="onChange($any($event.target).checked)">
    `, isInline: true, styles: [":host input,:host select,:host textarea{width:100%;line-height:normal;padding:.375em .75em}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CheckboxEditorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'checkbox-editor', template: `
    <input [ngClass]="inputClass"
           type="checkbox"
           [name]="cell.getId()"
           [disabled]="!cell.isEditable()"
           [checked]="cell.getValue() === trueVal"
           (click)="onClick.emit($event)"
           (change)="onChange($any($event.target).checked)">
    `, standalone: false, styles: [":host input,:host select,:host textarea{width:100%;line-height:normal;padding:.375em .75em}\n"] }]
        }], ctorParameters: () => [] });

class InputEditorComponent extends DefaultEditor {
    constructor() {
        super();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: InputEditorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: InputEditorComponent, isStandalone: false, selector: "input-editor", usesInheritance: true, ngImport: i0, template: `
    <input [ngClass]="inputClass"
           [value]="cell.getValue()"
           [name]="cell.getId()"
           [placeholder]="cell.getTitle()"
           [disabled]="!cell.isEditable()"
           (click)="onClick.emit($event)"
           (keyup)="cell.setValue($any($event.target).value)"
           (keydown.enter)="disableEnterKeySave || onEdited.emit()"
           (keydown.esc)="onStopEditing.emit()">
    `, isInline: true, styles: [":host input,:host select,:host textarea{width:100%;line-height:normal;padding:.375em .75em}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: InputEditorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'input-editor', template: `
    <input [ngClass]="inputClass"
           [value]="cell.getValue()"
           [name]="cell.getId()"
           [placeholder]="cell.getTitle()"
           [disabled]="!cell.isEditable()"
           (click)="onClick.emit($event)"
           (keyup)="cell.setValue($any($event.target).value)"
           (keydown.enter)="disableEnterKeySave || onEdited.emit()"
           (keydown.esc)="onStopEditing.emit()">
    `, standalone: false, styles: [":host input,:host select,:host textarea{width:100%;line-height:normal;padding:.375em .75em}\n"] }]
        }], ctorParameters: () => [] });

class SelectEditorComponent extends DefaultEditor {
    constructor() {
        super();
    }
    get editorConfig() {
        return this.cell.getColumn().getConfig();
    }
    onSelectionChanged(newValue) {
        this.cell.setValue(newValue);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: SelectEditorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: SelectEditorComponent, isStandalone: false, selector: "select-editor", usesInheritance: true, ngImport: i0, template: `
    <select [ngClass]="inputClass"
            (change)="onSelectionChanged($any($event.target).value)"
            [name]="cell.getId()"
            [disabled]="!cell.isEditable()"
            (click)="onClick.emit($event)"
            (keydown.enter)="disableEnterKeySave || onEdited.emit()"
            (keydown.esc)="onStopEditing.emit()"
    >
        <option value="">{{ editorConfig.selectText ?? 'Select...' }}</option>
        <option *ngFor="let option of editorConfig.list" [value]="option.value"
                [selected]="option.value === cell.getRawValue()">{{ option.title }}
        </option>
    </select>
    `, isInline: true, styles: [":host input,:host select,:host textarea{width:100%;line-height:normal;padding:.375em .75em}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: SelectEditorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'select-editor', template: `
    <select [ngClass]="inputClass"
            (change)="onSelectionChanged($any($event.target).value)"
            [name]="cell.getId()"
            [disabled]="!cell.isEditable()"
            (click)="onClick.emit($event)"
            (keydown.enter)="disableEnterKeySave || onEdited.emit()"
            (keydown.esc)="onStopEditing.emit()"
    >
        <option value="">{{ editorConfig.selectText ?? 'Select...' }}</option>
        <option *ngFor="let option of editorConfig.list" [value]="option.value"
                [selected]="option.value === cell.getRawValue()">{{ option.title }}
        </option>
    </select>
    `, standalone: false, styles: [":host input,:host select,:host textarea{width:100%;line-height:normal;padding:.375em .75em}\n"] }]
        }], ctorParameters: () => [] });

class TextareaEditorComponent extends DefaultEditor {
    constructor() {
        super();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TextareaEditorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TextareaEditorComponent, isStandalone: false, selector: "textarea-editor", usesInheritance: true, ngImport: i0, template: `
    <textarea [ngClass]="inputClass"
              [value]="cell.getValue()"
              [name]="cell.getId()"
              [disabled]="!cell.isEditable()"
              [placeholder]="cell.getTitle()"
              (click)="onClick.emit($event)"
              (keyup)="cell.setValue($any($event.target).value)"
              (keydown.enter)="disableEnterKeySave || onEdited.emit()"
              (keydown.esc)="onStopEditing.emit()">
    </textarea>
    `, isInline: true, styles: [":host input,:host select,:host textarea{width:100%;line-height:normal;padding:.375em .75em}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TextareaEditorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'textarea-editor', template: `
    <textarea [ngClass]="inputClass"
              [value]="cell.getValue()"
              [name]="cell.getId()"
              [disabled]="!cell.isEditable()"
              [placeholder]="cell.getTitle()"
              (click)="onClick.emit($event)"
              (keyup)="cell.setValue($any($event.target).value)"
              (keydown.enter)="disableEnterKeySave || onEdited.emit()"
              (keydown.esc)="onStopEditing.emit()">
    </textarea>
    `, standalone: false, styles: [":host input,:host select,:host textarea{width:100%;line-height:normal;padding:.375em .75em}\n"] }]
        }], ctorParameters: () => [] });

class DefaultEditComponent extends EditCellDefault {
    constructor() {
        super();
    }
    getEditorType() {
        const editor = this.cell.getColumn().editor;
        if (!editor) {
            return 'default';
        }
        return editor.type;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DefaultEditComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: DefaultEditComponent, isStandalone: false, selector: "table-cell-default-editor", usesInheritance: true, ngImport: i0, template: "<div [ngSwitch]=\"getEditorType()\">\r\n    <select-editor *ngSwitchCase=\"'list'\"\r\n                   [cell]=\"cell\"\r\n                   [inputClass]=\"inputClass\"\r\n                   (onClick)=\"onClick($event)\"\r\n                   (onEdited)=\"onEdited()\"\r\n                   (onStopEditing)=\"onStopEditing()\">\r\n    </select-editor>\r\n\r\n    <textarea-editor *ngSwitchCase=\"'textarea'\"\r\n                     [cell]=\"cell\"\r\n                     [inputClass]=\"inputClass\"\r\n                     (onClick)=\"onClick($event)\"\r\n                     (onEdited)=\"onEdited()\"\r\n                     (onStopEditing)=\"onStopEditing()\">\r\n    </textarea-editor>\r\n\r\n    <checkbox-editor *ngSwitchCase=\"'checkbox'\"\r\n                     [cell]=\"cell\"\r\n                     [inputClass]=\"inputClass\"\r\n                     (onClick)=\"onClick($event)\">\r\n    </checkbox-editor>\r\n\r\n    <input-editor *ngSwitchDefault\r\n                  [cell]=\"cell\"\r\n                  [inputClass]=\"inputClass\"\r\n                  (onClick)=\"onClick($event)\"\r\n                  (onEdited)=\"onEdited()\"\r\n                  (onStopEditing)=\"onStopEditing()\">\r\n    </input-editor>\r\n</div>\r\n", dependencies: [{ kind: "directive", type: i1.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i1.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i1.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "component", type: CheckboxEditorComponent, selector: "checkbox-editor" }, { kind: "component", type: InputEditorComponent, selector: "input-editor" }, { kind: "component", type: SelectEditorComponent, selector: "select-editor" }, { kind: "component", type: TextareaEditorComponent, selector: "textarea-editor" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DefaultEditComponent, decorators: [{
            type: Component,
            args: [{ selector: 'table-cell-default-editor', standalone: false, template: "<div [ngSwitch]=\"getEditorType()\">\r\n    <select-editor *ngSwitchCase=\"'list'\"\r\n                   [cell]=\"cell\"\r\n                   [inputClass]=\"inputClass\"\r\n                   (onClick)=\"onClick($event)\"\r\n                   (onEdited)=\"onEdited()\"\r\n                   (onStopEditing)=\"onStopEditing()\">\r\n    </select-editor>\r\n\r\n    <textarea-editor *ngSwitchCase=\"'textarea'\"\r\n                     [cell]=\"cell\"\r\n                     [inputClass]=\"inputClass\"\r\n                     (onClick)=\"onClick($event)\"\r\n                     (onEdited)=\"onEdited()\"\r\n                     (onStopEditing)=\"onStopEditing()\">\r\n    </textarea-editor>\r\n\r\n    <checkbox-editor *ngSwitchCase=\"'checkbox'\"\r\n                     [cell]=\"cell\"\r\n                     [inputClass]=\"inputClass\"\r\n                     (onClick)=\"onClick($event)\">\r\n    </checkbox-editor>\r\n\r\n    <input-editor *ngSwitchDefault\r\n                  [cell]=\"cell\"\r\n                  [inputClass]=\"inputClass\"\r\n                  (onClick)=\"onClick($event)\"\r\n                  (onEdited)=\"onEdited()\"\r\n                  (onStopEditing)=\"onStopEditing()\">\r\n    </input-editor>\r\n</div>\r\n" }]
        }], ctorParameters: () => [] });

class EditCellComponent {
    cell;
    inputClass = '';
    edited = new EventEmitter();
    stopEditing = new EventEmitter();
    ngOnInit() {
        this.cell.resetValue();
    }
    getEditorType() {
        const editor = this.cell.getColumn().editor;
        if (!editor) {
            return 'default';
        }
        return editor.type;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: EditCellComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: EditCellComponent, isStandalone: false, selector: "table-cell-edit-mode", inputs: { cell: "cell", inputClass: "inputClass" }, outputs: { edited: "edited", stopEditing: "stopEditing" }, ngImport: i0, template: `
      <div [ngSwitch]="getEditorType()">
        <table-cell-custom-editor *ngSwitchCase="'custom'"
                                  [cell]="cell"
                                  [inputClass]="inputClass"
                                  (edited)="edited.emit()"
                                  (stopEditing)="stopEditing.emit()"
        ></table-cell-custom-editor>
        <table-cell-default-editor *ngSwitchDefault
                                   [cell]="cell"
                                   [inputClass]="inputClass"
                                   (edited)="edited.emit()"
                                   (stopEditing)="stopEditing.emit()"
        ></table-cell-default-editor>
      </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i1.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i1.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "component", type: CustomEditComponent, selector: "table-cell-custom-editor" }, { kind: "component", type: DefaultEditComponent, selector: "table-cell-default-editor" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: EditCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'table-cell-edit-mode',
                    template: `
      <div [ngSwitch]="getEditorType()">
        <table-cell-custom-editor *ngSwitchCase="'custom'"
                                  [cell]="cell"
                                  [inputClass]="inputClass"
                                  (edited)="edited.emit()"
                                  (stopEditing)="stopEditing.emit()"
        ></table-cell-custom-editor>
        <table-cell-default-editor *ngSwitchDefault
                                   [cell]="cell"
                                   [inputClass]="inputClass"
                                   (edited)="edited.emit()"
                                   (stopEditing)="stopEditing.emit()"
        ></table-cell-default-editor>
      </div>
    `,
                    standalone: false
                }]
        }], propDecorators: { cell: [{
                type: Input
            }], inputClass: [{
                type: Input
            }], edited: [{
                type: Output
            }], stopEditing: [{
                type: Output
            }] } });

class CustomViewComponent {
    customComponent;
    cell;
    dynamicTarget;
    ngOnInit() {
        if (this.cell && !this.customComponent) {
            this.customComponent = this.dynamicTarget.createComponent(this.cell.getColumn().renderComponent);
            const componentInitFunction = this.cell.getColumn().componentInitFunction;
            if (componentInitFunction === undefined) {
                console.error('Since version 3.0.0, a custom renderer always needs a componentInitFunction');
            }
            else {
                componentInitFunction(this.customComponent.instance, this.cell);
            }
        }
    }
    ngOnDestroy() {
        this.customComponent.destroy();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CustomViewComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: CustomViewComponent, isStandalone: false, selector: "custom-view-component", inputs: { cell: "cell" }, viewQueries: [{ propertyName: "dynamicTarget", first: true, predicate: ["dynamicTarget"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: `
    <ng-template #dynamicTarget></ng-template>
  `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CustomViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'custom-view-component',
                    template: `
    <ng-template #dynamicTarget></ng-template>
  `,
                    standalone: false
                }]
        }], propDecorators: { cell: [{
                type: Input
            }], dynamicTarget: [{
                type: ViewChild,
                args: ['dynamicTarget', { read: ViewContainerRef, static: true }]
            }] } });

class BypassSecurityTrustPipe {
    sanitizer;
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    transform(value, type) {
        switch (type) {
            case 'html': return this.sanitizer.bypassSecurityTrustHtml(value);
            case 'style': return this.sanitizer.bypassSecurityTrustStyle(value);
            case 'script': return this.sanitizer.bypassSecurityTrustScript(value);
            case 'url': return this.sanitizer.bypassSecurityTrustUrl(value);
            case 'resourceUrl': return this.sanitizer.bypassSecurityTrustResourceUrl(value);
            case 'none': return value;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: BypassSecurityTrustPipe, deps: [{ token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: BypassSecurityTrustPipe, isStandalone: false, name: "bypassSecurityTrust" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: BypassSecurityTrustPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'bypassSecurityTrust',
                    standalone: false
                }]
        }], ctorParameters: () => [{ type: i1$1.DomSanitizer }] });

class ViewCellComponent {
    cell;
    get bypassSecurityTrust() {
        return this.cell.getColumn().sanitizer.bypassHtml ? 'html' : 'none';
    }
    get cssClass() {
        return this.cell.getColumn().classContent;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ViewCellComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: ViewCellComponent, isStandalone: false, selector: "table-cell-view-mode", inputs: { cell: "cell" }, ngImport: i0, template: `
    <div [ngSwitch]="cell.getColumn().type">
        <custom-view-component *ngSwitchCase="'custom'" [cell]="cell"></custom-view-component>
        <div *ngSwitchCase="'html'" [innerHTML]="cell.getValue() | bypassSecurityTrust: bypassSecurityTrust" [ngClass]="cssClass"></div>
        <div *ngSwitchDefault [ngClass]="cssClass">{{ cell.getValue() }}</div>
    </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i1.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i1.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "component", type: CustomViewComponent, selector: "custom-view-component", inputs: ["cell"] }, { kind: "pipe", type: BypassSecurityTrustPipe, name: "bypassSecurityTrust" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ViewCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'table-cell-view-mode',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
    <div [ngSwitch]="cell.getColumn().type">
        <custom-view-component *ngSwitchCase="'custom'" [cell]="cell"></custom-view-component>
        <div *ngSwitchCase="'html'" [innerHTML]="cell.getValue() | bypassSecurityTrust: bypassSecurityTrust" [ngClass]="cssClass"></div>
        <div *ngSwitchDefault [ngClass]="cssClass">{{ cell.getValue() }}</div>
    </div>
    `,
                    standalone: false
                }]
        }], propDecorators: { cell: [{
                type: Input
            }] } });

class CellComponent {
    grid;
    row;
    cell;
    inputClass = '';
    mode = 'inline';
    isInEditing = false;
    isNew;
    // if isNew === false
    editConfirm;
    editCancel;
    // if isNew === true
    createConfirm;
    createCancel;
    onEdited() {
        if (this.isNew) {
            this.grid.create(this.grid.createFormRow, this.createConfirm);
        }
        else {
            this.grid.save(this.row, this.editConfirm);
        }
    }
    onStopEditing() {
        if (this.isNew) {
            this.grid.createFormShown = false;
            this.createCancel.emit({
                discardedData: this.grid.createFormRow.getNewData(),
                source: this.grid.source,
            });
        }
        else {
            this.row.isInEditing = false;
            this.editCancel.emit({
                row: this.row,
                data: this.row.getData(),
                discardedData: this.row.getNewData(),
                source: this.grid.source,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CellComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: CellComponent, isStandalone: false, selector: "angular2-smart-table-cell", inputs: { grid: "grid", row: "row", cell: "cell", inputClass: "inputClass", mode: "mode", isInEditing: "isInEditing", isNew: "isNew", editConfirm: "editConfirm", editCancel: "editCancel", createConfirm: "createConfirm", createCancel: "createCancel" }, ngImport: i0, template: `
    <table-cell-view-mode *ngIf="!isInEditing" [cell]="cell"></table-cell-view-mode>
    <table-cell-edit-mode *ngIf="isInEditing" [cell]="cell"
                          [inputClass]="inputClass"
                          (edited)="onEdited()"
                          (stopEditing)="onStopEditing()"
    ></table-cell-edit-mode>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: EditCellComponent, selector: "table-cell-edit-mode", inputs: ["cell", "inputClass"], outputs: ["edited", "stopEditing"] }, { kind: "component", type: ViewCellComponent, selector: "table-cell-view-mode", inputs: ["cell"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'angular2-smart-table-cell',
                    template: `
    <table-cell-view-mode *ngIf="!isInEditing" [cell]="cell"></table-cell-view-mode>
    <table-cell-edit-mode *ngIf="isInEditing" [cell]="cell"
                          [inputClass]="inputClass"
                          (edited)="onEdited()"
                          (stopEditing)="onStopEditing()"
    ></table-cell-edit-mode>
  `,
                    standalone: false
                }]
        }], propDecorators: { grid: [{
                type: Input
            }], row: [{
                type: Input
            }], cell: [{
                type: Input
            }], inputClass: [{
                type: Input
            }], mode: [{
                type: Input
            }], isInEditing: [{
                type: Input
            }], isNew: [{
                type: Input
            }], editConfirm: [{
                type: Input
            }], editCancel: [{
                type: Input
            }], createConfirm: [{
                type: Input
            }], createCancel: [{
                type: Input
            }] } });

class TbodySaveCancelComponent {
    grid;
    row;
    editConfirm;
    editCancel;
    cancelButtonContent;
    saveButtonContent;
    bypassSecurityTrust = 'none';
    onSave(event) {
        event.preventDefault();
        event.stopPropagation();
        this.grid.save(this.row, this.editConfirm);
    }
    onCancelEdit(event) {
        event.preventDefault();
        event.stopPropagation();
        this.row.isInEditing = false;
        this.editCancel.emit({
            row: this.row,
            data: this.row.getData(),
            discardedData: this.row.getNewData(),
            source: this.grid.source,
        });
    }
    ngOnChanges() {
        // we can assume that default settings have been applied and all values are defined
        this.saveButtonContent = this.grid.settings.edit.saveButtonContent;
        this.cancelButtonContent = this.grid.settings.edit.cancelButtonContent;
        this.bypassSecurityTrust = this.grid.settings.edit?.sanitizer?.bypassHtml ? 'html' : 'none';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TbodySaveCancelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TbodySaveCancelComponent, isStandalone: false, selector: "angular2-st-tbody-create-cancel", inputs: { grid: "grid", row: "row", editConfirm: "editConfirm", editCancel: "editCancel" }, usesOnChanges: true, ngImport: i0, template: `
    <a href="#" class="angular2-smart-action angular2-smart-action-edit-save"
        [innerHTML]="saveButtonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onSave($event)"></a>
    <a href="#" class="angular2-smart-action angular2-smart-action-edit-cancel"
        [innerHTML]="cancelButtonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onCancelEdit($event)"></a>
  `, isInline: true, dependencies: [{ kind: "pipe", type: BypassSecurityTrustPipe, name: "bypassSecurityTrust" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TbodySaveCancelComponent, decorators: [{
            type: Component,
            args: [{
                    // TODO: @breaking-change rename the selector to angular2-st-tbody-save-cancel in the next major version
                    selector: 'angular2-st-tbody-create-cancel',
                    template: `
    <a href="#" class="angular2-smart-action angular2-smart-action-edit-save"
        [innerHTML]="saveButtonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onSave($event)"></a>
    <a href="#" class="angular2-smart-action angular2-smart-action-edit-cancel"
        [innerHTML]="cancelButtonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onCancelEdit($event)"></a>
  `,
                    standalone: false
                }]
        }], propDecorators: { grid: [{
                type: Input
            }], row: [{
                type: Input
            }], editConfirm: [{
                type: Input
            }], editCancel: [{
                type: Input
            }] } });

class TbodyEditDeleteComponent {
    grid;
    row;
    source;
    deleteConfirm;
    edit = new EventEmitter();
    delete = new EventEmitter();
    editRowSelect = new EventEmitter();
    editRowButtonContent;
    editButtonBypassSecurityTrust = 'none';
    editHiddenWhenFunction = (_) => false;
    editDisabledWhenFunction = (_) => false;
    deleteHiddenWhenFunction = (_) => false;
    deleteDisabledWhenFunction = (_) => false;
    deleteRowButtonContent;
    deleteButtonBypassSecurityTrust = 'none';
    onEdit(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.editDisabled)
            return;
        this.editRowSelect.emit(this.row);
        if (this.grid.settings.mode === 'external') {
            this.edit.emit({
                row: this.row,
                data: this.row.getData(),
                source: this.source,
            });
        }
        else {
            this.grid.edit(this.row);
        }
    }
    onDelete(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.deleteDisabled)
            return;
        if (this.grid.settings.mode === 'external') {
            this.delete.emit({
                row: this.row,
                data: this.row.getData(),
                source: this.source,
            });
        }
        else {
            this.grid.delete(this.row, this.deleteConfirm);
        }
    }
    get editVisible() {
        return !this.editHiddenWhenFunction(this.row);
    }
    get editDisabled() {
        return this.editDisabledWhenFunction(this.row);
    }
    get deleteVisible() {
        return !this.deleteHiddenWhenFunction(this.row);
    }
    get deleteDisabled() {
        return this.deleteDisabledWhenFunction(this.row);
    }
    ngOnChanges() {
        const actions = this.grid.settings.actions;
        if (actions === false || actions === undefined) {
            // handle the "flexibility" of this property....
            this.editHiddenWhenFunction = (_) => (actions === false);
            this.deleteHiddenWhenFunction = (_) => (actions === false);
            return;
        }
        this.editRowButtonContent = this.grid.settings.edit?.editButtonContent ?? 'Edit';
        this.editButtonBypassSecurityTrust = this.grid.settings.edit?.sanitizer?.bypassHtml ? 'html' : 'none';
        this.editHiddenWhenFunction = this.grid.settings.edit?.hiddenWhen ?? ((_) => (actions.edit === false));
        this.editDisabledWhenFunction = this.grid.settings.edit?.disabledWhen ?? this.editDisabledWhenFunction;
        this.deleteRowButtonContent = this.grid.settings.delete?.deleteButtonContent ?? 'Delete';
        this.deleteButtonBypassSecurityTrust = this.grid.settings.delete?.sanitizer?.bypassHtml ? 'html' : 'none';
        this.deleteHiddenWhenFunction = this.grid.settings.delete?.hiddenWhen ?? ((_) => (actions.delete === false));
        this.deleteDisabledWhenFunction = this.grid.settings.delete?.disabledWhen ?? this.deleteDisabledWhenFunction;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TbodyEditDeleteComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TbodyEditDeleteComponent, isStandalone: false, selector: "angular2-st-tbody-edit-delete", inputs: { grid: "grid", row: "row", source: "source", deleteConfirm: "deleteConfirm" }, outputs: { edit: "edit", delete: "delete", editRowSelect: "editRowSelect" }, usesOnChanges: true, ngImport: i0, template: `
    <a href="#" *ngIf="editVisible" class="angular2-smart-action angular2-smart-action-edit-edit"
       [ngClass]="{'not-allowed': editDisabled}"
       [innerHTML]="editRowButtonContent | bypassSecurityTrust: editButtonBypassSecurityTrust"
       (click)="onEdit($event)"></a>
    <a href="#" *ngIf="deleteVisible" class="angular2-smart-action angular2-smart-action-delete-delete"
       [ngClass]="{'not-allowed': deleteDisabled}"
       [innerHTML]="deleteRowButtonContent | bypassSecurityTrust: deleteButtonBypassSecurityTrust" (click)="onDelete($event)"></a>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: BypassSecurityTrustPipe, name: "bypassSecurityTrust" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TbodyEditDeleteComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'angular2-st-tbody-edit-delete',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
    <a href="#" *ngIf="editVisible" class="angular2-smart-action angular2-smart-action-edit-edit"
       [ngClass]="{'not-allowed': editDisabled}"
       [innerHTML]="editRowButtonContent | bypassSecurityTrust: editButtonBypassSecurityTrust"
       (click)="onEdit($event)"></a>
    <a href="#" *ngIf="deleteVisible" class="angular2-smart-action angular2-smart-action-delete-delete"
       [ngClass]="{'not-allowed': deleteDisabled}"
       [innerHTML]="deleteRowButtonContent | bypassSecurityTrust: deleteButtonBypassSecurityTrust" (click)="onDelete($event)"></a>
  `,
                    standalone: false
                }]
        }], propDecorators: { grid: [{
                type: Input
            }], row: [{
                type: Input
            }], source: [{
                type: Input
            }], deleteConfirm: [{
                type: Input
            }], edit: [{
                type: Output
            }], delete: [{
                type: Output
            }], editRowSelect: [{
                type: Output
            }] } });

class TbodyCustomItemComponent {
    customComponent;
    action;
    row;
    dynamicTarget;
    ngOnInit() {
        this.customComponent = this.dynamicTarget.createComponent(this.action.renderComponent);
        Object.assign(this.customComponent.instance, this.getPatch());
    }
    ngOnDestroy() {
        this.customComponent.destroy();
    }
    getPatch() {
        return {
            action: this.action,
            rowData: this.row.getData(),
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TbodyCustomItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TbodyCustomItemComponent, isStandalone: false, selector: "angular2-st-tbody-custom-item", inputs: { action: "action", row: "row" }, viewQueries: [{ propertyName: "dynamicTarget", first: true, predicate: ["dynamicTarget"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: `
    <ng-template #dynamicTarget></ng-template>
  `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TbodyCustomItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'angular2-st-tbody-custom-item',
                    template: `
    <ng-template #dynamicTarget></ng-template>
  `,
                    standalone: false
                }]
        }], propDecorators: { action: [{
                type: Input
            }], row: [{
                type: Input
            }], dynamicTarget: [{
                type: ViewChild,
                args: ['dynamicTarget', { read: ViewContainerRef, static: true }]
            }] } });

class TbodyCustomComponent {
    grid;
    row;
    source;
    custom = new EventEmitter();
    get customActions() {
        if (this.grid.settings.actions === false)
            return [];
        return this.grid.settings.actions?.custom ?? [];
    }
    buttonContent(action) {
        return action.customButtonContent ?? action.title ?? action.name;
    }
    bypassSecurityTrustFor(action) {
        return (action.sanitizer?.bypassHtml ?? false) ? 'html' : 'none';
    }
    showAction(action) {
        return action.hiddenWhen === undefined || !action.hiddenWhen(this.row);
    }
    disableAction(action) {
        return action.disabledWhen !== undefined && action.disabledWhen(this.row);
    }
    onCustom(action, event) {
        event.preventDefault();
        event.stopPropagation();
        this.custom.emit({
            action: action.name,
            row: this.row,
            data: this.row.getData(),
            source: this.source,
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TbodyCustomComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TbodyCustomComponent, isStandalone: false, selector: "angular2-st-tbody-custom", inputs: { grid: "grid", row: "row", source: "source" }, outputs: { custom: "custom" }, ngImport: i0, template: `
      <ng-container *ngFor="let action of customActions">
          <a href="#" class="angular2-smart-action angular2-smart-action-custom-custom"
             *ngIf="!action.renderComponent && showAction(action)"
             [ngClass]="{'not-allowed': disableAction(action)}"
             [innerHTML]="buttonContent(action) | bypassSecurityTrust: bypassSecurityTrustFor(action)"
             (click)="onCustom(action, $event)"
          ></a>
          <a href="#" class="angular2-smart-action angular2-smart-action-custom-custom"
             *ngIf="action.renderComponent && showAction(action)"
             [ngClass]="{'not-allowed': disableAction(action)}"
             (click)="onCustom(action, $event)"
          >
              <angular2-st-tbody-custom-item
                      class="angular2-smart-action angular2-smart-action-custom-custom"
                      [action]="action"
                      [row]="row"
              ></angular2-st-tbody-custom-item>
          </a>
      </ng-container>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: TbodyCustomItemComponent, selector: "angular2-st-tbody-custom-item", inputs: ["action", "row"] }, { kind: "pipe", type: BypassSecurityTrustPipe, name: "bypassSecurityTrust" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TbodyCustomComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'angular2-st-tbody-custom',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
      <ng-container *ngFor="let action of customActions">
          <a href="#" class="angular2-smart-action angular2-smart-action-custom-custom"
             *ngIf="!action.renderComponent && showAction(action)"
             [ngClass]="{'not-allowed': disableAction(action)}"
             [innerHTML]="buttonContent(action) | bypassSecurityTrust: bypassSecurityTrustFor(action)"
             (click)="onCustom(action, $event)"
          ></a>
          <a href="#" class="angular2-smart-action angular2-smart-action-custom-custom"
             *ngIf="action.renderComponent && showAction(action)"
             [ngClass]="{'not-allowed': disableAction(action)}"
             (click)="onCustom(action, $event)"
          >
              <angular2-st-tbody-custom-item
                      class="angular2-smart-action angular2-smart-action-custom-custom"
                      [action]="action"
                      [row]="row"
              ></angular2-st-tbody-custom-item>
          </a>
      </ng-container>
  `,
                    standalone: false
                }]
        }], propDecorators: { grid: [{
                type: Input
            }], row: [{
                type: Input
            }], source: [{
                type: Input
            }], custom: [{
                type: Output
            }] } });

class TbodyExpandRowComponent {
    grid;
    row;
    onExpandRow = new EventEmitter();
    buttonContent;
    bypassSecurityTrust = 'none';
    hiddenWhenFunction = (_) => false;
    disabledWhenFunction = (_) => false;
    constructor() {
    }
    get visible() {
        return !this.hiddenWhenFunction(this.row);
    }
    get disabled() {
        return this.disabledWhenFunction(this.row);
    }
    onExpand(event) {
        event.preventDefault();
        event.stopPropagation();
        if (!this.disabled) {
            this.onExpandRow.emit(this.row);
        }
    }
    ngOnChanges() {
        this.buttonContent = this.grid.settings.expand?.buttonContent ?? 'Expand';
        this.bypassSecurityTrust = this.grid.settings.expand?.sanitizer?.bypassHtml ? 'html' : 'none';
        this.hiddenWhenFunction = this.grid.settings.expand?.hiddenWhen ?? this.hiddenWhenFunction;
        this.disabledWhenFunction = this.grid.settings.expand?.disabledWhen ?? this.disabledWhenFunction;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TbodyExpandRowComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TbodyExpandRowComponent, isStandalone: false, selector: "angular2-st-tbody-expand", inputs: { grid: "grid", row: "row" }, outputs: { onExpandRow: "onExpandRow" }, usesOnChanges: true, ngImport: i0, template: `
      <a *ngIf="visible" href="#" class="angular2-smart-action angular2-smart-action-expand-expand"
         [ngClass]="{'not-allowed': disabled}"
         [innerHTML]="buttonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onExpand($event)"></a>
    `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: BypassSecurityTrustPipe, name: "bypassSecurityTrust" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TbodyExpandRowComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'angular2-st-tbody-expand',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
      <a *ngIf="visible" href="#" class="angular2-smart-action angular2-smart-action-expand-expand"
         [ngClass]="{'not-allowed': disabled}"
         [innerHTML]="buttonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onExpand($event)"></a>
    `,
                    standalone: false
                }]
        }], ctorParameters: () => [], propDecorators: { grid: [{
                type: Input
            }], row: [{
                type: Input
            }], onExpandRow: [{
                type: Output
            }] } });

class NgxSmartTableTbodyComponent {
    grid;
    source;
    deleteConfirm;
    editConfirm;
    editCancel;
    rowClassFunction;
    edit = new EventEmitter();
    delete = new EventEmitter();
    custom = new EventEmitter();
    userSelectRow = new EventEmitter();
    editRowSelect = new EventEmitter();
    multipleSelectRow = new EventEmitter();
    rowHover = new EventEmitter();
    onExpandRow = new EventEmitter();
    expandedRowChild;
    expandedRowComponent;
    hasChildComponent = false;
    ngAfterViewInit() {
        let cmp = this.grid.getExpandedRowComponentClass();
        if (cmp !== undefined && !this.expandedRowComponent) {
            this.expandedRowChild.forEach(c => c.clear());
            this.hasChildComponent = true;
            this.createExpandedRowComponent();
        }
    }
    ngOnDestroy() {
        if (this.expandedRowComponent)
            this.expandedRowComponent.destroy();
    }
    createExpandedRowComponent() {
        const cmp = this.grid.getExpandedRowComponentClass();
        if (cmp !== undefined) {
            this.expandedRowChild.changes
                .pipe(delay(0))
                .subscribe((list) => {
                if (list.length) {
                    this.expandedRowComponent = list.first.createComponent(cmp);
                    Object.assign(this.expandedRowComponent.instance, this.grid.dataSet.expandRow, {
                        rowData: this.grid.dataSet.getExpandedRow().getData(),
                    });
                }
            });
        }
    }
    isMultiSelectVisible;
    showActionColumnLeft;
    showActionColumnRight;
    mode;
    editInputClass;
    noDataMessage;
    get tableColumnsCount() {
        const actionColumn = (this.showActionColumnLeft || this.showActionColumnRight) ? 1 : 0;
        const selectColumn = this.isMultiSelectVisible ? 1 : 0;
        return this.grid.getColumns().length + actionColumn + selectColumn;
    }
    ngOnChanges() {
        this.isMultiSelectVisible = this.grid.isMultiSelectVisible();
        this.showActionColumnLeft = this.grid.showActionColumn('left');
        this.mode = this.grid.settings.mode ?? 'inline';
        this.editInputClass = this.grid.settings.edit?.inputClass ?? '';
        this.showActionColumnRight = this.grid.showActionColumn('right');
        this.noDataMessage = this.grid.settings.noDataMessage;
    }
    getVisibleCells(cells) {
        return (cells || []).filter((cell) => !cell.getColumn().hide);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: NgxSmartTableTbodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: NgxSmartTableTbodyComponent, isStandalone: false, selector: "[angular2-st-tbody]", inputs: { grid: "grid", source: "source", deleteConfirm: "deleteConfirm", editConfirm: "editConfirm", editCancel: "editCancel", rowClassFunction: "rowClassFunction" }, outputs: { edit: "edit", delete: "delete", custom: "custom", userSelectRow: "userSelectRow", editRowSelect: "editRowSelect", multipleSelectRow: "multipleSelectRow", rowHover: "rowHover", onExpandRow: "onExpandRow" }, viewQueries: [{ propertyName: "expandedRowChild", predicate: ["expandedRowChild"], descendants: true, read: ViewContainerRef }], usesOnChanges: true, ngImport: i0, template: "<ng-container  *ngFor=\"let row of grid.getRows()\">\r\n  <tr (click)=\"userSelectRow.emit(row)\" (mouseover)=\"rowHover.emit(row)\" class=\"angular2-smart-row\" [className]=\"rowClassFunction(row)\" [ngClass]=\"{selected: row.isSelected}\">\r\n    <td *ngIf=\"isMultiSelectVisible\" class=\"angular2-smart-actions angular2-smart-action-multiple-select\" (click)=\"multipleSelectRow.emit(row)\">\r\n      <input type=\"checkbox\" [checked]=\"row.isSelected\">\r\n    </td>\r\n    <td *ngIf=\"!row.isInEditing && showActionColumnLeft\" class=\"angular2-smart-actions\">\r\n\r\n      <angular2-st-tbody-custom\r\n        [grid]=\"grid\"\r\n        (custom)=\"custom.emit($event)\"\r\n        [row]=\"row\"\r\n        [source]=\"source\">\r\n      </angular2-st-tbody-custom>\r\n\r\n      <angular2-st-tbody-expand\r\n          *ngIf=\"hasChildComponent\"\r\n          [grid]=\"grid\"\r\n          [row]=\"row\"\r\n          (onExpandRow)=\"onExpandRow.emit(row)\">\r\n      </angular2-st-tbody-expand>\r\n\r\n      <angular2-st-tbody-edit-delete [grid]=\"grid\"\r\n                                [deleteConfirm]=\"deleteConfirm\"\r\n                                (edit)=\"edit.emit($event)\"\r\n                                (delete)=\"delete.emit($event)\"\r\n                                (editRowSelect)=\"editRowSelect.emit($event)\"\r\n                                [row]=\"row\"\r\n                                [source]=\"source\">\r\n      </angular2-st-tbody-edit-delete>\r\n    </td>\r\n    <td *ngIf=\"row.isInEditing && showActionColumnLeft\"  class=\"angular2-smart-actions\">\r\n      <angular2-st-tbody-create-cancel [grid]=\"grid\" [row]=\"row\" [editConfirm]=\"editConfirm\" [editCancel]=\"editCancel\"></angular2-st-tbody-create-cancel>\r\n    </td>\r\n    <ng-container *ngFor=\"let cell of getVisibleCells(row.cells)\">\r\n      <td *ngIf=\"!cell.getColumn().isRowHeading\">\r\n        <angular2-smart-table-cell\r\n          [cell]=\"cell\"\r\n          [grid]=\"grid\"\r\n          [row]=\"row\"\r\n          [isNew]=\"false\"\r\n          [mode]=\"mode\"\r\n          [editConfirm]=\"editConfirm\"\r\n          [editCancel]=\"editCancel\"\r\n          [inputClass]=\"editInputClass\"\r\n          [isInEditing]=\"row.isInEditing\"\r\n        ></angular2-smart-table-cell>\r\n      </td>\r\n      <th *ngIf=\"cell.getColumn().isRowHeading\" scope=\"row\">\r\n        <angular2-smart-table-cell\r\n          [cell]=\"cell\"\r\n          [grid]=\"grid\"\r\n          [row]=\"row\"\r\n          [isNew]=\"false\"\r\n          [mode]=\"mode\"\r\n          [editConfirm]=\"editConfirm\"\r\n          [editCancel]=\"editCancel\"\r\n          [inputClass]=\"editInputClass\"\r\n          [isInEditing]=\"row.isInEditing\"\r\n        ></angular2-smart-table-cell>\r\n      </th>\r\n    </ng-container>\r\n\r\n    <td *ngIf=\"row.isInEditing && showActionColumnRight\"  class=\"angular2-smart-actions\">\r\n      <angular2-st-tbody-create-cancel [grid]=\"grid\" [row]=\"row\" [editConfirm]=\"editConfirm\" [editCancel]=\"editCancel\"></angular2-st-tbody-create-cancel>\r\n    </td>\r\n\r\n    <td *ngIf=\"!row.isInEditing && showActionColumnRight\" class=\"angular2-smart-actions\">\r\n      <angular2-st-tbody-custom [grid]=\"grid\" (custom)=\"custom.emit($event)\" [row]=\"row\" [source]=\"source\"></angular2-st-tbody-custom>\r\n\r\n      <angular2-st-tbody-expand\r\n          *ngIf=\"hasChildComponent\"\r\n          [grid]=\"grid\"\r\n          [row]=\"row\"\r\n          (onExpandRow)=\"onExpandRow.emit(row)\">\r\n      </angular2-st-tbody-expand>\r\n\r\n      <angular2-st-tbody-edit-delete [grid]=\"grid\"\r\n                                [deleteConfirm]=\"deleteConfirm\"\r\n                                [row]=\"row\"\r\n                                [source]=\"source\"\r\n                                (edit)=\"edit.emit($event)\"\r\n                                (delete)=\"delete.emit($event)\"\r\n                                (editRowSelect)=\"editRowSelect.emit($event)\">\r\n      </angular2-st-tbody-edit-delete>\r\n    </td>\r\n  </tr>\r\n  <tr class=\"angular2-smart-row angular2-smart-row-detail\" *ngIf=\"row.isExpanded\">\r\n    <td [attr.colspan]=\"tableColumnsCount\" class=\"angular2-smart-column-expandedDetail\">\r\n      <ng-template #expandedRowChild ></ng-template>\r\n    </td>\r\n  </tr>\r\n</ng-container>\r\n<tr *ngIf=\"grid.getRows().length == 0\">\r\n  <td [attr.colspan]=\"tableColumnsCount\">\r\n    {{ noDataMessage }}\r\n  </td>\r\n</tr>\r\n", styles: [":host .angular2-smart-row.selected{background:#0000000d}:host .angular2-smart-row .angular2-smart-actions.angular2-smart-action-multiple-select{text-align:center}:host ::ng-deep angular2-st-tbody-edit-delete a:first-child,:host ::ng-deep angular2-st-tbody-create-cancel a:first-child,:host ::ng-deep angular2-st-tbody-expand a:first-child{margin-right:.25rem}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: CellComponent, selector: "angular2-smart-table-cell", inputs: ["grid", "row", "cell", "inputClass", "mode", "isInEditing", "isNew", "editConfirm", "editCancel", "createConfirm", "createCancel"] }, { kind: "component", type: TbodySaveCancelComponent, selector: "angular2-st-tbody-create-cancel", inputs: ["grid", "row", "editConfirm", "editCancel"] }, { kind: "component", type: TbodyEditDeleteComponent, selector: "angular2-st-tbody-edit-delete", inputs: ["grid", "row", "source", "deleteConfirm"], outputs: ["edit", "delete", "editRowSelect"] }, { kind: "component", type: TbodyCustomComponent, selector: "angular2-st-tbody-custom", inputs: ["grid", "row", "source"], outputs: ["custom"] }, { kind: "component", type: TbodyExpandRowComponent, selector: "angular2-st-tbody-expand", inputs: ["grid", "row"], outputs: ["onExpandRow"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: NgxSmartTableTbodyComponent, decorators: [{
            type: Component,
            args: [{ selector: '[angular2-st-tbody]', standalone: false, template: "<ng-container  *ngFor=\"let row of grid.getRows()\">\r\n  <tr (click)=\"userSelectRow.emit(row)\" (mouseover)=\"rowHover.emit(row)\" class=\"angular2-smart-row\" [className]=\"rowClassFunction(row)\" [ngClass]=\"{selected: row.isSelected}\">\r\n    <td *ngIf=\"isMultiSelectVisible\" class=\"angular2-smart-actions angular2-smart-action-multiple-select\" (click)=\"multipleSelectRow.emit(row)\">\r\n      <input type=\"checkbox\" [checked]=\"row.isSelected\">\r\n    </td>\r\n    <td *ngIf=\"!row.isInEditing && showActionColumnLeft\" class=\"angular2-smart-actions\">\r\n\r\n      <angular2-st-tbody-custom\r\n        [grid]=\"grid\"\r\n        (custom)=\"custom.emit($event)\"\r\n        [row]=\"row\"\r\n        [source]=\"source\">\r\n      </angular2-st-tbody-custom>\r\n\r\n      <angular2-st-tbody-expand\r\n          *ngIf=\"hasChildComponent\"\r\n          [grid]=\"grid\"\r\n          [row]=\"row\"\r\n          (onExpandRow)=\"onExpandRow.emit(row)\">\r\n      </angular2-st-tbody-expand>\r\n\r\n      <angular2-st-tbody-edit-delete [grid]=\"grid\"\r\n                                [deleteConfirm]=\"deleteConfirm\"\r\n                                (edit)=\"edit.emit($event)\"\r\n                                (delete)=\"delete.emit($event)\"\r\n                                (editRowSelect)=\"editRowSelect.emit($event)\"\r\n                                [row]=\"row\"\r\n                                [source]=\"source\">\r\n      </angular2-st-tbody-edit-delete>\r\n    </td>\r\n    <td *ngIf=\"row.isInEditing && showActionColumnLeft\"  class=\"angular2-smart-actions\">\r\n      <angular2-st-tbody-create-cancel [grid]=\"grid\" [row]=\"row\" [editConfirm]=\"editConfirm\" [editCancel]=\"editCancel\"></angular2-st-tbody-create-cancel>\r\n    </td>\r\n    <ng-container *ngFor=\"let cell of getVisibleCells(row.cells)\">\r\n      <td *ngIf=\"!cell.getColumn().isRowHeading\">\r\n        <angular2-smart-table-cell\r\n          [cell]=\"cell\"\r\n          [grid]=\"grid\"\r\n          [row]=\"row\"\r\n          [isNew]=\"false\"\r\n          [mode]=\"mode\"\r\n          [editConfirm]=\"editConfirm\"\r\n          [editCancel]=\"editCancel\"\r\n          [inputClass]=\"editInputClass\"\r\n          [isInEditing]=\"row.isInEditing\"\r\n        ></angular2-smart-table-cell>\r\n      </td>\r\n      <th *ngIf=\"cell.getColumn().isRowHeading\" scope=\"row\">\r\n        <angular2-smart-table-cell\r\n          [cell]=\"cell\"\r\n          [grid]=\"grid\"\r\n          [row]=\"row\"\r\n          [isNew]=\"false\"\r\n          [mode]=\"mode\"\r\n          [editConfirm]=\"editConfirm\"\r\n          [editCancel]=\"editCancel\"\r\n          [inputClass]=\"editInputClass\"\r\n          [isInEditing]=\"row.isInEditing\"\r\n        ></angular2-smart-table-cell>\r\n      </th>\r\n    </ng-container>\r\n\r\n    <td *ngIf=\"row.isInEditing && showActionColumnRight\"  class=\"angular2-smart-actions\">\r\n      <angular2-st-tbody-create-cancel [grid]=\"grid\" [row]=\"row\" [editConfirm]=\"editConfirm\" [editCancel]=\"editCancel\"></angular2-st-tbody-create-cancel>\r\n    </td>\r\n\r\n    <td *ngIf=\"!row.isInEditing && showActionColumnRight\" class=\"angular2-smart-actions\">\r\n      <angular2-st-tbody-custom [grid]=\"grid\" (custom)=\"custom.emit($event)\" [row]=\"row\" [source]=\"source\"></angular2-st-tbody-custom>\r\n\r\n      <angular2-st-tbody-expand\r\n          *ngIf=\"hasChildComponent\"\r\n          [grid]=\"grid\"\r\n          [row]=\"row\"\r\n          (onExpandRow)=\"onExpandRow.emit(row)\">\r\n      </angular2-st-tbody-expand>\r\n\r\n      <angular2-st-tbody-edit-delete [grid]=\"grid\"\r\n                                [deleteConfirm]=\"deleteConfirm\"\r\n                                [row]=\"row\"\r\n                                [source]=\"source\"\r\n                                (edit)=\"edit.emit($event)\"\r\n                                (delete)=\"delete.emit($event)\"\r\n                                (editRowSelect)=\"editRowSelect.emit($event)\">\r\n      </angular2-st-tbody-edit-delete>\r\n    </td>\r\n  </tr>\r\n  <tr class=\"angular2-smart-row angular2-smart-row-detail\" *ngIf=\"row.isExpanded\">\r\n    <td [attr.colspan]=\"tableColumnsCount\" class=\"angular2-smart-column-expandedDetail\">\r\n      <ng-template #expandedRowChild ></ng-template>\r\n    </td>\r\n  </tr>\r\n</ng-container>\r\n<tr *ngIf=\"grid.getRows().length == 0\">\r\n  <td [attr.colspan]=\"tableColumnsCount\">\r\n    {{ noDataMessage }}\r\n  </td>\r\n</tr>\r\n", styles: [":host .angular2-smart-row.selected{background:#0000000d}:host .angular2-smart-row .angular2-smart-actions.angular2-smart-action-multiple-select{text-align:center}:host ::ng-deep angular2-st-tbody-edit-delete a:first-child,:host ::ng-deep angular2-st-tbody-create-cancel a:first-child,:host ::ng-deep angular2-st-tbody-expand a:first-child{margin-right:.25rem}\n"] }]
        }], propDecorators: { grid: [{
                type: Input
            }], source: [{
                type: Input
            }], deleteConfirm: [{
                type: Input
            }], editConfirm: [{
                type: Input
            }], editCancel: [{
                type: Input
            }], rowClassFunction: [{
                type: Input
            }], edit: [{
                type: Output
            }], delete: [{
                type: Output
            }], custom: [{
                type: Output
            }], userSelectRow: [{
                type: Output
            }], editRowSelect: [{
                type: Output
            }], multipleSelectRow: [{
                type: Output
            }], rowHover: [{
                type: Output
            }], onExpandRow: [{
                type: Output
            }], expandedRowChild: [{
                type: ViewChildren,
                args: ['expandedRowChild', { read: ViewContainerRef }]
            }] } });

class TableService {
    mouseMoveEvent$ = new Subject();
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TableService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TableService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TableService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class FilterDefault {
    column;
    source;
    inputClass = '';
    debounceTime = 300;
    query = '';
    onFilter(query) {
        if (query === '') {
            this.source.removeFilter(this.column.id);
        }
        else {
            this.source.addFilter({
                field: this.column.id,
                search: query,
                filter: this.column.filterFunction,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: FilterDefault, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: FilterDefault, isStandalone: false, selector: "ng-component", inputs: { column: "column", source: "source", inputClass: "inputClass", debounceTime: "debounceTime", query: "query" }, ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: FilterDefault, decorators: [{
            type: Component,
            args: [{
                    template: '',
                    standalone: false
                }]
        }], propDecorators: { column: [{
                type: Input
            }], source: [{
                type: Input
            }], inputClass: [{
                type: Input
            }], debounceTime: [{
                type: Input
            }], query: [{
                type: Input
            }] } });

class DefaultFilter {
    subject = new Subject();
    changesSubscription;
    query = '';
    inputClass;
    debounceTime = 300;
    column;
    filter = new EventEmitter();
    ngOnInit() {
        this.changesSubscription = this.subject
            .pipe(distinctUntilChanged(), debounceTime(this.debounceTime))
            .subscribe(value => this.setFilter());
    }
    ngOnDestroy() {
        this.changesSubscription?.unsubscribe();
    }
    onValueChanged(value) {
        this.query = value;
        this.subject.next(value);
    }
    setFilter() {
        this.filter.emit(this.query);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DefaultFilter, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: DefaultFilter, isStandalone: false, selector: "ng-component", inputs: { query: "query", inputClass: "inputClass", debounceTime: "debounceTime", column: "column" }, outputs: { filter: "filter" }, ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DefaultFilter, decorators: [{
            type: Component,
            args: [{
                    template: '',
                    standalone: false
                }]
        }], propDecorators: { query: [{
                type: Input
            }], inputClass: [{
                type: Input
            }], debounceTime: [{
                type: Input
            }], column: [{
                type: Input
            }], filter: [{
                type: Output
            }] } });

class CheckboxFilterComponent extends DefaultFilter {
    filterActive = false;
    checked = false;
    trueVal = 'true';
    falseVal = 'false';
    resetText = 'reset';
    ngOnInit() {
        if (this.column.filter.config !== undefined) {
            const config = this.column.filter.config;
            this.trueVal = config?.true ?? 'true';
            this.falseVal = config?.false ?? 'false';
            this.resetText = config?.resetText ?? 'reset';
        }
        super.ngOnInit();
    }
    onChecked(checked) {
        this.filterActive = true;
        this.checked = checked;
        this.onValueChanged(checked ? this.trueVal : this.falseVal);
    }
    resetFilter(event) {
        event.preventDefault();
        this.query = '';
        this.checked = false;
        this.filterActive = false;
        this.setFilter();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CheckboxFilterComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: CheckboxFilterComponent, isStandalone: false, selector: "checkbox-filter", usesInheritance: true, ngImport: i0, template: `
    <input type="checkbox" (change)="onChecked($any($event.target).checked)" [checked]="checked" [ngClass]="inputClass">
    <a href="#" *ngIf="filterActive" (click)="resetFilter($event)">{{resetText}}</a>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CheckboxFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'checkbox-filter',
                    template: `
    <input type="checkbox" (change)="onChecked($any($event.target).checked)" [checked]="checked" [ngClass]="inputClass">
    <a href="#" *ngIf="filterActive" (click)="resetFilter($event)">{{resetText}}</a>
  `,
                    standalone: false
                }]
        }] });

class InputFilterComponent extends DefaultFilter {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: InputFilterComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: InputFilterComponent, isStandalone: false, selector: "input-filter", usesInheritance: true, ngImport: i0, template: `
    <input
      [ngClass]="inputClass"
      type="text"
      [value]="query"
      (change)="onValueChanged($any($event.target).value)"
      (keyup)="onValueChanged($any($event.target).value)"
      placeholder="{{ column.placeholder || column.title }}"/>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: InputFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'input-filter',
                    template: `
    <input
      [ngClass]="inputClass"
      type="text"
      [value]="query"
      (change)="onValueChanged($any($event.target).value)"
      (keyup)="onValueChanged($any($event.target).value)"
      placeholder="{{ column.placeholder || column.title }}"/>
  `,
                    standalone: false
                }]
        }] });

class SelectFilterComponent extends DefaultFilter {
    config;
    ngOnInit() {
        this.config = this.column.filter.config;
        // if no filter function is provided, but filtering shall be strict, define the respective filter
        const strict = this.config.strict === undefined || this.config.strict;
        if (this.column.filterFunction === undefined && strict) {
            this.column.filterFunction = (v, f) => v?.toString() === f;
        }
        super.ngOnInit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: SelectFilterComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: SelectFilterComponent, isStandalone: false, selector: "select-filter", usesInheritance: true, ngImport: i0, template: `
    <select [ngClass]="inputClass"
            [value]="query"
            (change)="onValueChanged($any($event.target).value)">
        <option value="">{{ config.selectText ?? 'Select...' }}</option>
        <option *ngFor="let option of config.list" [value]="option.value">
          {{ option.title }}
        </option>
    </select>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: SelectFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'select-filter',
                    template: `
    <select [ngClass]="inputClass"
            [value]="query"
            (change)="onValueChanged($any($event.target).value)">
        <option value="">{{ config.selectText ?? 'Select...' }}</option>
        <option *ngFor="let option of config.list" [value]="option.value">
          {{ option.title }}
        </option>
    </select>
  `,
                    standalone: false
                }]
        }] });

class DefaultFilterComponent extends FilterDefault {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DefaultFilterComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: DefaultFilterComponent, isStandalone: false, selector: "default-table-filter", usesInheritance: true, ngImport: i0, template: `
    <ng-container [ngSwitch]="column.filter.type">
      <select-filter *ngSwitchCase="'list'"
                     [query]="query"
                     [inputClass]="inputClass"
                     [debounceTime]="debounceTime"
                     [column]="column"
                     (filter)="onFilter($event)">
      </select-filter>
      <checkbox-filter *ngSwitchCase="'checkbox'"
                       [query]="query"
                       [inputClass]="inputClass"
                       [debounceTime]="debounceTime"
                       [column]="column"
                       (filter)="onFilter($event)">
      </checkbox-filter>
      <input-filter *ngSwitchDefault
                    [query]="query"
                    [inputClass]="inputClass"
                    [debounceTime]="debounceTime"
                    [column]="column"
                    (filter)="onFilter($event)">
      </input-filter>
    </ng-container>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i1.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i1.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "component", type: CheckboxFilterComponent, selector: "checkbox-filter" }, { kind: "component", type: InputFilterComponent, selector: "input-filter" }, { kind: "component", type: SelectFilterComponent, selector: "select-filter" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DefaultFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'default-table-filter',
                    template: `
    <ng-container [ngSwitch]="column.filter.type">
      <select-filter *ngSwitchCase="'list'"
                     [query]="query"
                     [inputClass]="inputClass"
                     [debounceTime]="debounceTime"
                     [column]="column"
                     (filter)="onFilter($event)">
      </select-filter>
      <checkbox-filter *ngSwitchCase="'checkbox'"
                       [query]="query"
                       [inputClass]="inputClass"
                       [debounceTime]="debounceTime"
                       [column]="column"
                       (filter)="onFilter($event)">
      </checkbox-filter>
      <input-filter *ngSwitchDefault
                    [query]="query"
                    [inputClass]="inputClass"
                    [debounceTime]="debounceTime"
                    [column]="column"
                    (filter)="onFilter($event)">
      </input-filter>
    </ng-container>
  `,
                    standalone: false
                }]
        }] });

class CustomFilterComponent extends FilterDefault {
    customComponent;
    dynamicTarget;
    ngOnChanges(changes) {
        if (this.column && !this.customComponent) {
            const filter = this.column.filter;
            if (!filter) {
                return;
            }
            this.customComponent = this.dynamicTarget.createComponent(filter.component);
            // set @Inputs and @Outputs of custom component
            this.customComponent.instance.query = this.query;
            this.customComponent.instance.column = this.column;
            this.customComponent.instance.source = this.source;
            this.customComponent.instance.inputClass = this.inputClass;
            this.customComponent.instance.debounceTime = this.debounceTime;
            this.customComponent.instance.filter.subscribe((event) => { this.onFilter(event); });
        }
        if (this.customComponent.instance.ngOnChanges !== undefined) {
            this.customComponent.instance.ngOnChanges(changes);
        }
    }
    ngOnDestroy() {
        if (this.customComponent) {
            this.customComponent.destroy();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CustomFilterComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: CustomFilterComponent, isStandalone: false, selector: "custom-table-filter", viewQueries: [{ propertyName: "dynamicTarget", first: true, predicate: ["dynamicTarget"], descendants: true, read: ViewContainerRef, static: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `<ng-template #dynamicTarget></ng-template>`, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CustomFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'custom-table-filter',
                    template: `<ng-template #dynamicTarget></ng-template>`,
                    standalone: false
                }]
        }], propDecorators: { dynamicTarget: [{
                type: ViewChild,
                args: ['dynamicTarget', { read: ViewContainerRef, static: true }]
            }] } });

class FilterComponent extends FilterDefault {
    query = '';
    dataChangedSub;
    ngOnChanges(changes) {
        if (changes.source) {
            if (!changes.source.firstChange) {
                this.dataChangedSub.unsubscribe();
            }
            this.dataChangedSub = this.source.onChanged().subscribe((dataChanges) => {
                let newQuery = '';
                for (const f of dataChanges.filter) {
                    if (f.field == this.column.id) {
                        newQuery = f.search;
                        break;
                    }
                }
                this.query = newQuery;
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: FilterComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: FilterComponent, isStandalone: false, selector: "angular2-smart-table-filter", usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
      <div class="angular2-smart-filter" *ngIf="column.isFilterable" [ngSwitch]="column.filter.type">
        <custom-table-filter *ngSwitchCase="'custom'"
                             [query]="query"
                             [column]="column"
                             [source]="source"
                             [inputClass]="inputClass"
                             [debounceTime]="debounceTime"
        ></custom-table-filter>
        <default-table-filter *ngSwitchDefault
                              [query]="query"
                              [column]="column"
                              [source]="source"
                              [inputClass]="inputClass"
                              [debounceTime]="debounceTime"
        ></default-table-filter>
      </div>
    `, isInline: true, styles: [":host .angular2-smart-filter ::ng-deep input,:host .angular2-smart-filter ::ng-deep select{width:100%;line-height:normal;padding:.375em .75em;font-weight:400}:host .angular2-smart-filter ::ng-deep input[type=search]{box-sizing:inherit}:host .angular2-smart-filter ::ng-deep a{font-weight:400}\n"], dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i1.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i1.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "component", type: DefaultFilterComponent, selector: "default-table-filter" }, { kind: "component", type: CustomFilterComponent, selector: "custom-table-filter" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: FilterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'angular2-smart-table-filter', template: `
      <div class="angular2-smart-filter" *ngIf="column.isFilterable" [ngSwitch]="column.filter.type">
        <custom-table-filter *ngSwitchCase="'custom'"
                             [query]="query"
                             [column]="column"
                             [source]="source"
                             [inputClass]="inputClass"
                             [debounceTime]="debounceTime"
        ></custom-table-filter>
        <default-table-filter *ngSwitchDefault
                              [query]="query"
                              [column]="column"
                              [source]="source"
                              [inputClass]="inputClass"
                              [debounceTime]="debounceTime"
        ></default-table-filter>
      </div>
    `, standalone: false, styles: [":host .angular2-smart-filter ::ng-deep input,:host .angular2-smart-filter ::ng-deep select{width:100%;line-height:normal;padding:.375em .75em;font-weight:400}:host .angular2-smart-filter ::ng-deep input[type=search]{box-sizing:inherit}:host .angular2-smart-filter ::ng-deep a{font-weight:400}\n"] }]
        }] });

class AddButtonComponent {
    ref;
    grid;
    source;
    create = new EventEmitter();
    hiddenWhenFunction = () => false;
    disabledWhenFunction = () => false;
    addNewButtonContent;
    bypassSecurityTrust = 'none';
    constructor(ref) {
        this.ref = ref;
    }
    ngAfterViewInit() {
        this.ref.nativeElement.classList.add('angular2-smart-actions-title', 'angular2-smart-actions-title-add');
    }
    get visible() {
        return !this.hiddenWhenFunction();
    }
    get disabled() {
        return this.disabledWhenFunction();
    }
    ngOnChanges() {
        this.addNewButtonContent = this.grid.settings.add?.addButtonContent ?? 'Add';
        this.bypassSecurityTrust = this.grid.settings.add?.sanitizer?.bypassHtml ? 'html' : 'none';
        this.disabledWhenFunction = this.grid.settings.add?.disabledWhen ?? this.disabledWhenFunction;
        const actions = this.grid.settings.actions;
        if (actions === false || actions === undefined) {
            this.hiddenWhenFunction = () => (actions === false);
        }
        else {
            this.hiddenWhenFunction = this.grid.settings.add?.hiddenWhen ?? (() => (actions.add === false));
        }
    }
    onAdd(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.disabled)
            return;
        if (this.grid.settings.mode === 'external') {
            this.create.emit({
                source: this.source,
            });
        }
        else {
            this.grid.showCreateForm();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: AddButtonComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: AddButtonComponent, isStandalone: false, selector: "[angular2-st-add-button]", inputs: { grid: "grid", source: "source" }, outputs: { create: "create" }, usesOnChanges: true, ngImport: i0, template: `
    <a *ngIf="visible" href="#" class="angular2-smart-action angular2-smart-action-add-add"
        [ngClass]="{'not-allowed': disabled}"
        [innerHTML]="addNewButtonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onAdd($event)"></a>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: BypassSecurityTrustPipe, name: "bypassSecurityTrust" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: AddButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[angular2-st-add-button]',
                    template: `
    <a *ngIf="visible" href="#" class="angular2-smart-action angular2-smart-action-add-add"
        [ngClass]="{'not-allowed': disabled}"
        [innerHTML]="addNewButtonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onAdd($event)"></a>
  `,
                    standalone: false
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { grid: [{
                type: Input
            }], source: [{
                type: Input
            }], create: [{
                type: Output
            }] } });

class TheadFitlersRowComponent {
    grid;
    source;
    create = new EventEmitter();
    isMultiSelectVisible;
    showActionColumnLeft;
    showActionColumnRight;
    filterInputClass;
    filterDebounceTime = 300;
    ngOnChanges(changes) {
        if (changes['grid'] !== undefined) {
            this.isMultiSelectVisible = this.grid.isMultiSelectVisible();
            this.showActionColumnLeft = this.grid.showActionColumn('left');
            this.showActionColumnRight = this.grid.showActionColumn('right');
            this.filterInputClass = this.grid.settings.filter?.inputClass ?? '';
            this.filterDebounceTime = this.grid.settings.filter?.debounceTime ?? 300;
        }
    }
    getVisibleColumns(columns) {
        return (columns || []).filter((column) => !column.hide);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TheadFitlersRowComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TheadFitlersRowComponent, isStandalone: false, selector: "[angular2-st-thead-filters-row]", inputs: { grid: "grid", source: "source" }, outputs: { create: "create" }, usesOnChanges: true, ngImport: i0, template: `
    <th *ngIf="isMultiSelectVisible" scope="col"></th>
    <th angular2-st-add-button
        *ngIf="showActionColumnLeft"
        [grid]="grid"
        (create)="create.emit($event)"
        scope="col"
    >
    </th>
    <th *ngFor="let column of getVisibleColumns(grid.getColumns())"
        class="angular2-smart-th {{ column.id }}"
        scope="col"
    >
      <angular2-smart-table-filter
        [source]="source"
        [column]="column"
        [inputClass]="filterInputClass"
        [debounceTime]="filterDebounceTime"
      ></angular2-smart-table-filter>
    </th>
    <th angular2-st-add-button
        *ngIf="showActionColumnRight"
        [grid]="grid"
        [source]="source"
        (create)="create.emit($event)"
        scope="col"
    >
    </th>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: FilterComponent, selector: "angular2-smart-table-filter" }, { kind: "component", type: AddButtonComponent, selector: "[angular2-st-add-button]", inputs: ["grid", "source"], outputs: ["create"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TheadFitlersRowComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[angular2-st-thead-filters-row]',
                    template: `
    <th *ngIf="isMultiSelectVisible" scope="col"></th>
    <th angular2-st-add-button
        *ngIf="showActionColumnLeft"
        [grid]="grid"
        (create)="create.emit($event)"
        scope="col"
    >
    </th>
    <th *ngFor="let column of getVisibleColumns(grid.getColumns())"
        class="angular2-smart-th {{ column.id }}"
        scope="col"
    >
      <angular2-smart-table-filter
        [source]="source"
        [column]="column"
        [inputClass]="filterInputClass"
        [debounceTime]="filterDebounceTime"
      ></angular2-smart-table-filter>
    </th>
    <th angular2-st-add-button
        *ngIf="showActionColumnRight"
        [grid]="grid"
        [source]="source"
        (create)="create.emit($event)"
        scope="col"
    >
    </th>
  `,
                    standalone: false
                }]
        }], propDecorators: { grid: [{
                type: Input
            }], source: [{
                type: Input
            }], create: [{
                type: Output
            }] } });

class TheadCreateCancelComponent {
    grid;
    createConfirm;
    createCancel;
    createButtonContent;
    cancelButtonContent;
    bypassSecurityTrust = 'none';
    onCreate(event) {
        event.preventDefault();
        event.stopPropagation();
        this.grid.create(this.grid.createFormRow, this.createConfirm);
    }
    onCancelCreate(event) {
        event.preventDefault();
        event.stopPropagation();
        this.grid.createFormShown = false;
        this.createCancel.emit({
            discardedData: this.grid.createFormRow.getNewData(),
            source: this.grid.source,
        });
    }
    ngOnChanges() {
        // we can assume that default settings have been applied and all values are defined
        this.createButtonContent = this.grid.settings.add.createButtonContent;
        this.cancelButtonContent = this.grid.settings.add.cancelButtonContent;
        this.bypassSecurityTrust = this.grid.settings.add?.sanitizer?.bypassHtml ? 'html' : 'none';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TheadCreateCancelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TheadCreateCancelComponent, isStandalone: false, selector: "angular2-st-actions", inputs: { grid: "grid", createConfirm: "createConfirm", createCancel: "createCancel" }, usesOnChanges: true, ngImport: i0, template: `
    <a href="#" class="angular2-smart-action angular2-smart-action-add-create"
        [innerHTML]="createButtonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onCreate($event)"></a>
    <a href="#" class="angular2-smart-action angular2-smart-action-add-cancel"
        [innerHTML]="cancelButtonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onCancelCreate($event)"></a>
  `, isInline: true, dependencies: [{ kind: "pipe", type: BypassSecurityTrustPipe, name: "bypassSecurityTrust" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TheadCreateCancelComponent, decorators: [{
            type: Component,
            args: [{
                    // TODO: @breaking-change rename the selector to angular2-st-thead-create-cancel in the next major version
                    selector: 'angular2-st-actions',
                    template: `
    <a href="#" class="angular2-smart-action angular2-smart-action-add-create"
        [innerHTML]="createButtonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onCreate($event)"></a>
    <a href="#" class="angular2-smart-action angular2-smart-action-add-cancel"
        [innerHTML]="cancelButtonContent | bypassSecurityTrust: bypassSecurityTrust" (click)="onCancelCreate($event)"></a>
  `,
                    standalone: false
                }]
        }], propDecorators: { grid: [{
                type: Input
            }], createConfirm: [{
                type: Input
            }], createCancel: [{
                type: Input
            }] } });

class TheadFormRowComponent {
    grid;
    row;
    createConfirm;
    createCancel;
    isMultiSelectVisible;
    showActionColumnLeft;
    showActionColumnRight;
    addInputClass;
    ngOnChanges() {
        this.isMultiSelectVisible = this.grid.isMultiSelectVisible();
        this.showActionColumnLeft = this.grid.showActionColumn('left');
        this.showActionColumnRight = this.grid.showActionColumn('right');
        this.addInputClass = this.grid.settings.add?.inputClass ?? '';
    }
    getVisibleCells(cells) {
        return (cells || []).filter((cell) => !cell.getColumn().hide);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TheadFormRowComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TheadFormRowComponent, isStandalone: false, selector: "[angular2-st-thead-form-row]", inputs: { grid: "grid", row: "row", createConfirm: "createConfirm", createCancel: "createCancel" }, usesOnChanges: true, ngImport: i0, template: `
    <td *ngIf="isMultiSelectVisible"></td>
    <td *ngIf="showActionColumnLeft" class="angular2-smart-actions">
      <angular2-st-actions [grid]="grid" [createConfirm]="createConfirm" [createCancel]="createCancel"></angular2-st-actions>
    </td>
    <td *ngFor="let cell of getVisibleCells(row.getCells())">
      <angular2-smart-table-cell
        [cell]="cell"
        [grid]="grid"
        [isNew]="true"
        [createConfirm]="createConfirm"
        [createCancel]="createCancel"
        [inputClass]="addInputClass"
        [isInEditing]="true"
      ></angular2-smart-table-cell>
    </td>
    <td *ngIf="showActionColumnRight" class="angular2-smart-actions">
      <angular2-st-actions [grid]="grid" [createConfirm]="createConfirm" [createCancel]="createCancel"></angular2-st-actions>
    </td>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: CellComponent, selector: "angular2-smart-table-cell", inputs: ["grid", "row", "cell", "inputClass", "mode", "isInEditing", "isNew", "editConfirm", "editCancel", "createConfirm", "createCancel"] }, { kind: "component", type: TheadCreateCancelComponent, selector: "angular2-st-actions", inputs: ["grid", "createConfirm", "createCancel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TheadFormRowComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[angular2-st-thead-form-row]',
                    template: `
    <td *ngIf="isMultiSelectVisible"></td>
    <td *ngIf="showActionColumnLeft" class="angular2-smart-actions">
      <angular2-st-actions [grid]="grid" [createConfirm]="createConfirm" [createCancel]="createCancel"></angular2-st-actions>
    </td>
    <td *ngFor="let cell of getVisibleCells(row.getCells())">
      <angular2-smart-table-cell
        [cell]="cell"
        [grid]="grid"
        [isNew]="true"
        [createConfirm]="createConfirm"
        [createCancel]="createCancel"
        [inputClass]="addInputClass"
        [isInEditing]="true"
      ></angular2-smart-table-cell>
    </td>
    <td *ngIf="showActionColumnRight" class="angular2-smart-actions">
      <angular2-st-actions [grid]="grid" [createConfirm]="createConfirm" [createCancel]="createCancel"></angular2-st-actions>
    </td>
  `,
                    standalone: false
                }]
        }], propDecorators: { grid: [{
                type: Input
            }], row: [{
                type: Input
            }], createConfirm: [{
                type: Input
            }], createCancel: [{
                type: Input
            }] } });

class NgxResizerDirective {
    elementRef;
    renderer;
    tableService;
    angular2SmartTableResizer;
    isClicked;
    parentElement;
    siblingElement;
    pointerOffset = 0;
    parentOffset = 0;
    siblingOffset = undefined;
    destroyed$ = new Subject();
    constructor(elementRef, renderer, tableService) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.tableService = tableService;
    }
    ngOnInit() {
        this.tableService.mouseMoveEvent$
            .pipe(takeUntil(this.destroyed$), filter(() => this.isClicked))
            .subscribe((event) => {
            const offset = this.pointerOffset - event.pageX;
            const width = this.parentOffset - offset;
            this.angular2SmartTableResizer.column.resizedWidth = width;
            this.renderer.setStyle(this.parentElement, 'width', width + 'px');
            const siblingColumn = this.angular2SmartTableResizer.siblingColumn;
            if (siblingColumn !== undefined && this.siblingOffset !== undefined) {
                const siblingWidth = this.siblingOffset + offset;
                siblingColumn.resizedWidth = siblingWidth;
                this.renderer.setStyle(this.siblingElement, 'width', siblingWidth + 'px');
            }
        });
    }
    onMouseEnter(event) {
        this.isClicked = true;
        this.parentElement = this.renderer.parentNode(this.elementRef.nativeElement);
        this.siblingElement = this.renderer.nextSibling(this.parentElement);
        this.pointerOffset = event.pageX;
        this.parentOffset = this.parentElement.offsetWidth;
        this.siblingOffset = this.siblingElement?.offsetWidth;
    }
    onMouseDown() {
        this.isClicked = false;
    }
    ngOnDestroy() {
        this.destroyed$.next(null);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: NgxResizerDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: TableService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.2.1", type: NgxResizerDirective, isStandalone: false, selector: "[angular2SmartTableResizer]", inputs: { angular2SmartTableResizer: "angular2SmartTableResizer" }, host: { listeners: { "mousedown": "onMouseEnter($event)", "document:mouseup": "onMouseDown()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: NgxResizerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[angular2SmartTableResizer]',
                    standalone: false
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: TableService }], propDecorators: { angular2SmartTableResizer: [{
                type: Input
            }], onMouseEnter: [{
                type: HostListener,
                args: ['mousedown', ['$event']]
            }], onMouseDown: [{
                type: HostListener,
                args: ['document:mouseup']
            }] } });

class ActionsTitleComponent {
    ref;
    grid;
    actionsColumnTitle;
    constructor(ref) {
        this.ref = ref;
    }
    ngAfterViewInit() {
        this.ref.nativeElement.classList.add('angular2-smart-actions');
    }
    ngOnChanges() {
        this.actionsColumnTitle = 'Actions';
        if (this.grid.settings.actions !== false) {
            this.actionsColumnTitle = this.grid.settings.actions?.columnTitle ?? 'Actions';
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ActionsTitleComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: ActionsTitleComponent, isStandalone: false, selector: "[angular2-st-actions-title]", inputs: { grid: "grid" }, usesOnChanges: true, ngImport: i0, template: `
    <div class="angular2-smart-title">{{ actionsColumnTitle }}</div>
  `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ActionsTitleComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[angular2-st-actions-title]',
                    template: `
    <div class="angular2-smart-title">{{ actionsColumnTitle }}</div>
  `,
                    standalone: false
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { grid: [{
                type: Input
            }] } });

class ColumnTitleComponent {
    currentDirection = null;
    multiSort = true;
    column;
    source;
    isHideable;
    hide = new EventEmitter();
    dataChangedSub = null;
    ngOnChanges(changes) {
        if (changes.source) {
            if (this.dataChangedSub !== null) {
                this.dataChangedSub.unsubscribe();
            }
            this.dataChangedSub = this.source.onChanged().subscribe(_ => {
                this.currentDirection = null;
                const sortConf = this.source.getSort();
                if (sortConf) {
                    sortConf.forEach(c => {
                        if (c.field === this.column.id) {
                            this.currentDirection = c.direction;
                        }
                    });
                }
            });
        }
    }
    ngOnDestroy() {
        if (this.dataChangedSub !== null) {
            this.dataChangedSub.unsubscribe();
            this.dataChangedSub = null;
        }
    }
    _sort(event) {
        event.preventDefault();
        this.changeSortDirection();
        const conf = {
            field: this.column.id,
            direction: this.currentDirection,
            compare: this.column.compareFunction,
        };
        if (this.multiSort) {
            this.source.updateSort([conf]);
        }
        else {
            this.source.setSort([conf]);
        }
    }
    _hideColumnClicked(event) {
        event.preventDefault();
        this.hide.emit(this.column.id);
    }
    changeSortDirection() {
        // rotate sort direction, including null (no sort)
        if (this.currentDirection === null) {
            this.currentDirection = 'asc';
        }
        else if (this.currentDirection === 'asc') {
            this.currentDirection = 'desc';
        }
        else if (this.currentDirection === 'desc') {
            this.currentDirection = null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ColumnTitleComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: ColumnTitleComponent, isStandalone: false, selector: "angular2-st-column-title", inputs: { multiSort: "multiSort", column: "column", source: "source", isHideable: "isHideable" }, outputs: { hide: "hide" }, usesOnChanges: true, ngImport: i0, template: `
    <a href="#" *ngIf="column.isSortable"
       (click)="_sort($event)"
       class="angular2-smart-sort-link sort"
       [ngClass]="currentDirection??''">
      {{ column.title }}
    </a>
    <span class="angular2-smart-sort" *ngIf="!column.isSortable">{{ column.title }}</span>
    <button style="position: absolute; top:0; right:0; border:none" *ngIf="isHideable"
            (click)="_hideColumnClicked($event)">🗙
    </button>
  `, isInline: true, styles: ["a.sort:after{display:inline-block;font-size:.8em;color:#a9a9a9;vertical-align:top}a.sort.asc:after{content:\"\\25b2\"}a.sort.desc:after{content:\"\\25bc\"}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ColumnTitleComponent, decorators: [{
            type: Component,
            args: [{ selector: 'angular2-st-column-title', template: `
    <a href="#" *ngIf="column.isSortable"
       (click)="_sort($event)"
       class="angular2-smart-sort-link sort"
       [ngClass]="currentDirection??''">
      {{ column.title }}
    </a>
    <span class="angular2-smart-sort" *ngIf="!column.isSortable">{{ column.title }}</span>
    <button style="position: absolute; top:0; right:0; border:none" *ngIf="isHideable"
            (click)="_hideColumnClicked($event)">🗙
    </button>
  `, standalone: false, styles: ["a.sort:after{display:inline-block;font-size:.8em;color:#a9a9a9;vertical-align:top}a.sort.asc:after{content:\"\\25b2\"}a.sort.desc:after{content:\"\\25bc\"}\n"] }]
        }], propDecorators: { multiSort: [{
                type: Input
            }], column: [{
                type: Input
            }], source: [{
                type: Input
            }], isHideable: [{
                type: Input
            }], hide: [{
                type: Output
            }] } });

class TheadTitlesRowComponent {
    grid;
    isAllSelected;
    source;
    hide = new EventEmitter();
    selectAllRows = new EventEmitter();
    multiSelectWidth = '3rem';
    isMultiSelectVisible;
    showActionColumnLeft;
    showActionColumnRight;
    isResizable;
    isHideable = false;
    ngOnChanges() {
        this.isMultiSelectVisible = this.grid.isMultiSelectVisible();
        this.showActionColumnLeft = this.grid.showActionColumn('left');
        this.showActionColumnRight = this.grid.showActionColumn('right');
        this.isResizable = this.grid.settings.resizable ?? false;
        this.isHideable = this.grid.settings.hideable ?? false;
    }
    get visibleColumns() {
        return (this.grid.getColumns() || []).filter((column) => !column.hide);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TheadTitlesRowComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TheadTitlesRowComponent, isStandalone: false, selector: "[angular2-st-thead-titles-row]", inputs: { grid: "grid", isAllSelected: "isAllSelected", source: "source" }, outputs: { hide: "hide", selectAllRows: "selectAllRows" }, usesOnChanges: true, ngImport: i0, template: `
    <th *ngIf="isMultiSelectVisible"
        [style.width]="multiSelectWidth"
        scope="col"
    >
      <input type="checkbox" [checked]="isAllSelected" (click)="selectAllRows.emit()">
    </th>
    <th angular2-st-actions-title *ngIf="showActionColumnLeft" [grid]="grid" scope="col"></th>
    <th *ngFor="let column of visibleColumns; index as i; last as isLast"
        class="angular2-smart-th {{ column.id }}"
        [ngClass]="column.classHeader"
        [style.width]="column.width"
        scope="col"
    >
      <angular2-st-column-title
        [source]="source"
        [column]="column"
        [isHideable]="isHideable"
        [multiSort]="grid.isMultiSortEnabled()"
        (hide)="hide.emit($event)"
      ></angular2-st-column-title>
      <div *ngIf="isResizable && (showActionColumnRight || !isLast)"
           [angular2SmartTableResizer]="{column: column, siblingColumn: isLast ? undefined : visibleColumns[i+1]}"
           class="angular2-resizer-block"
      ></div>
    </th>
    <th angular2-st-actions-title *ngIf="showActionColumnRight" [grid]="grid" scope="col"></th>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgxResizerDirective, selector: "[angular2SmartTableResizer]", inputs: ["angular2SmartTableResizer"] }, { kind: "component", type: ActionsTitleComponent, selector: "[angular2-st-actions-title]", inputs: ["grid"] }, { kind: "component", type: ColumnTitleComponent, selector: "angular2-st-column-title", inputs: ["multiSort", "column", "source", "isHideable"], outputs: ["hide"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TheadTitlesRowComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[angular2-st-thead-titles-row]',
                    template: `
    <th *ngIf="isMultiSelectVisible"
        [style.width]="multiSelectWidth"
        scope="col"
    >
      <input type="checkbox" [checked]="isAllSelected" (click)="selectAllRows.emit()">
    </th>
    <th angular2-st-actions-title *ngIf="showActionColumnLeft" [grid]="grid" scope="col"></th>
    <th *ngFor="let column of visibleColumns; index as i; last as isLast"
        class="angular2-smart-th {{ column.id }}"
        [ngClass]="column.classHeader"
        [style.width]="column.width"
        scope="col"
    >
      <angular2-st-column-title
        [source]="source"
        [column]="column"
        [isHideable]="isHideable"
        [multiSort]="grid.isMultiSortEnabled()"
        (hide)="hide.emit($event)"
      ></angular2-st-column-title>
      <div *ngIf="isResizable && (showActionColumnRight || !isLast)"
           [angular2SmartTableResizer]="{column: column, siblingColumn: isLast ? undefined : visibleColumns[i+1]}"
           class="angular2-resizer-block"
      ></div>
    </th>
    <th angular2-st-actions-title *ngIf="showActionColumnRight" [grid]="grid" scope="col"></th>
  `,
                    standalone: false
                }]
        }], propDecorators: { grid: [{
                type: Input
            }], isAllSelected: [{
                type: Input
            }], source: [{
                type: Input
            }], hide: [{
                type: Output
            }], selectAllRows: [{
                type: Output
            }] } });

class NgxSmartTableTheadComponent {
    tableService;
    grid;
    source;
    isAllSelected;
    createConfirm;
    createCancel;
    hide = new EventEmitter();
    selectAllRows = new EventEmitter();
    create = new EventEmitter();
    isHideHeader;
    isHideSubHeader;
    constructor(tableService) {
        this.tableService = tableService;
    }
    ngOnChanges() {
        this.isHideHeader = this.grid.settings.hideHeader ?? false;
        this.isHideSubHeader = this.grid.settings.hideSubHeader ?? false;
    }
    mouseMove(event) {
        this.tableService.mouseMoveEvent$.next(event);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: NgxSmartTableTheadComponent, deps: [{ token: TableService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: NgxSmartTableTheadComponent, isStandalone: false, selector: "[angular2-st-thead]", inputs: { grid: "grid", source: "source", isAllSelected: "isAllSelected", createConfirm: "createConfirm", createCancel: "createCancel" }, outputs: { hide: "hide", selectAllRows: "selectAllRows", create: "create" }, host: { listeners: { "mousemove": "mouseMove($event)" } }, usesOnChanges: true, ngImport: i0, template: "<tr angular2-st-thead-titles-row *ngIf=\"!isHideHeader\"\r\n    class=\"angular2-smart-titles\"\r\n    [grid]=\"grid\"\r\n    [isAllSelected]=\"isAllSelected\"\r\n    [source]=\"source\"\r\n    (hide)=\"hide.emit($event)\"\r\n    (selectAllRows)=\"selectAllRows.emit()\"\r\n></tr>\r\n\r\n<tr angular2-st-thead-filters-row *ngIf=\"!isHideSubHeader\"\r\n    class=\"angular2-smart-filters\"\r\n    [grid]=\"grid\"\r\n    [source]=\"source\"\r\n    (create)=\"create.emit($event)\"\r\n></tr>\r\n\r\n<tr angular2-st-thead-form-row *ngIf=\"grid.createFormShown\"\r\n    [grid]=\"grid\"\r\n    [row]=\"grid.createFormRow\"\r\n    [createConfirm]=\"createConfirm\"\r\n    [createCancel]=\"createCancel\"\r\n></tr>\r\n", styles: [":host ::ng-deep angular2-st-actions a:first-child{margin-right:.25rem}\n"], dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: TheadFitlersRowComponent, selector: "[angular2-st-thead-filters-row]", inputs: ["grid", "source"], outputs: ["create"] }, { kind: "component", type: TheadFormRowComponent, selector: "[angular2-st-thead-form-row]", inputs: ["grid", "row", "createConfirm", "createCancel"] }, { kind: "component", type: TheadTitlesRowComponent, selector: "[angular2-st-thead-titles-row]", inputs: ["grid", "isAllSelected", "source"], outputs: ["hide", "selectAllRows"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: NgxSmartTableTheadComponent, decorators: [{
            type: Component,
            args: [{ selector: '[angular2-st-thead]', standalone: false, template: "<tr angular2-st-thead-titles-row *ngIf=\"!isHideHeader\"\r\n    class=\"angular2-smart-titles\"\r\n    [grid]=\"grid\"\r\n    [isAllSelected]=\"isAllSelected\"\r\n    [source]=\"source\"\r\n    (hide)=\"hide.emit($event)\"\r\n    (selectAllRows)=\"selectAllRows.emit()\"\r\n></tr>\r\n\r\n<tr angular2-st-thead-filters-row *ngIf=\"!isHideSubHeader\"\r\n    class=\"angular2-smart-filters\"\r\n    [grid]=\"grid\"\r\n    [source]=\"source\"\r\n    (create)=\"create.emit($event)\"\r\n></tr>\r\n\r\n<tr angular2-st-thead-form-row *ngIf=\"grid.createFormShown\"\r\n    [grid]=\"grid\"\r\n    [row]=\"grid.createFormRow\"\r\n    [createConfirm]=\"createConfirm\"\r\n    [createCancel]=\"createCancel\"\r\n></tr>\r\n", styles: [":host ::ng-deep angular2-st-actions a:first-child{margin-right:.25rem}\n"] }]
        }], ctorParameters: () => [{ type: TableService }], propDecorators: { grid: [{
                type: Input
            }], source: [{
                type: Input
            }], isAllSelected: [{
                type: Input
            }], createConfirm: [{
                type: Input
            }], createCancel: [{
                type: Input
            }], hide: [{
                type: Output
            }], selectAllRows: [{
                type: Output
            }], create: [{
                type: Output
            }], mouseMove: [{
                type: HostListener,
                args: ['mousemove', ['$event']]
            }] } });

class TagComponent {
    item;
    close = new EventEmitter();
    closeClicked(evt) {
        evt.stopPropagation();
        this.close.emit(this.item.key);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TagComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TagComponent, isStandalone: false, selector: "angular2-smart-table-tag", inputs: { item: "item" }, outputs: { close: "close" }, ngImport: i0, template: "<div style=\"padding: .25em; display: inline; white-space: nowrap\">\r\n  <svg\r\n    (click)=\"closeClicked($event)\"\r\n    style=\"width: 1.2em; cursor: pointer\"\r\n    aria-hidden=\"true\"\r\n    focusable=\"false\"\r\n    role=\"img\"\r\n    viewBox=\"0 0 64 64\"\r\n    id=\"svg19\"\r\n    xmlns=\"http://www.w3.org/2000/svg\">\r\n    <defs id=\"defs23\"/>\r\n    <path\r\n      fill=\"currentColor\"\r\n      d=\"m 32.271186,1.2711864 c -17.125,0 -30.9999996,13.8749996 -30.9999996,30.9999996 0,17.125 13.8749996,31 30.9999996,31 17.125,0 31,-13.875 31,-31 0,-17.125 -13.875,-30.9999996 -31,-30.9999996 z m 15.2,39.1374996 c 0.5875,0.5875 0.5875,1.5375 0,2.125 l -4.95,4.9375 c -0.5875,0.5875 -1.5375,0.5875 -2.125,0 l -8.125,-8.2 -8.1375,8.2 c -0.5875,0.5875 -1.5375,0.5875 -2.125,0 l -4.9375,-4.95 c -0.5875,-0.5875 -0.5875,-1.5375 0,-2.125 l 8.2,-8.125 -8.2,-8.1375 c -0.5875,-0.5875 -0.5875,-1.5375 0,-2.125 l 4.95,-4.95 c 0.5875,-0.5875 1.5375,-0.5875 2.125,0 l 8.125,8.2125 8.1375,-8.2 c 0.5875,-0.5875 1.5375,-0.5875 2.125,0 l 4.95,4.95 c 0.5875,0.5875 0.5875,1.5375 0,2.125 l -8.2125,8.125 z\"\r\n      id=\"path17\"\r\n      style=\"stroke-width:0.125\"/>\r\n  </svg>\r\n  <span style=\"margin-left: 3px; font-size: 1.5em\">{{ item.value }}</span>\r\n</div>\r\n" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TagComponent, decorators: [{
            type: Component,
            args: [{ selector: 'angular2-smart-table-tag', standalone: false, template: "<div style=\"padding: .25em; display: inline; white-space: nowrap\">\r\n  <svg\r\n    (click)=\"closeClicked($event)\"\r\n    style=\"width: 1.2em; cursor: pointer\"\r\n    aria-hidden=\"true\"\r\n    focusable=\"false\"\r\n    role=\"img\"\r\n    viewBox=\"0 0 64 64\"\r\n    id=\"svg19\"\r\n    xmlns=\"http://www.w3.org/2000/svg\">\r\n    <defs id=\"defs23\"/>\r\n    <path\r\n      fill=\"currentColor\"\r\n      d=\"m 32.271186,1.2711864 c -17.125,0 -30.9999996,13.8749996 -30.9999996,30.9999996 0,17.125 13.8749996,31 30.9999996,31 17.125,0 31,-13.875 31,-31 0,-17.125 -13.875,-30.9999996 -31,-30.9999996 z m 15.2,39.1374996 c 0.5875,0.5875 0.5875,1.5375 0,2.125 l -4.95,4.9375 c -0.5875,0.5875 -1.5375,0.5875 -2.125,0 l -8.125,-8.2 -8.1375,8.2 c -0.5875,0.5875 -1.5375,0.5875 -2.125,0 l -4.9375,-4.95 c -0.5875,-0.5875 -0.5875,-1.5375 0,-2.125 l 8.2,-8.125 -8.2,-8.1375 c -0.5875,-0.5875 -0.5875,-1.5375 0,-2.125 l 4.95,-4.95 c 0.5875,-0.5875 1.5375,-0.5875 2.125,0 l 8.125,8.2125 8.1375,-8.2 c 0.5875,-0.5875 1.5375,-0.5875 2.125,0 l 4.95,4.95 c 0.5875,0.5875 0.5875,1.5375 0,2.125 l -8.2125,8.125 z\"\r\n      id=\"path17\"\r\n      style=\"stroke-width:0.125\"/>\r\n  </svg>\r\n  <span style=\"margin-left: 3px; font-size: 1.5em\">{{ item.value }}</span>\r\n</div>\r\n" }]
        }], propDecorators: { item: [{
                type: Input
            }], close: [{
                type: Output
            }] } });

class TagsListComponent {
    tags;
    close = new EventEmitter();
    closedTag(tagKey) {
        this.close.emit(tagKey);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TagsListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: TagsListComponent, isStandalone: false, selector: "angular2-smart-table-tags-list", inputs: { tags: "tags" }, outputs: { close: "close" }, ngImport: i0, template: "<div>\r\n  <angular2-smart-table-tag\r\n    *ngFor=\"let tag of tags\"\r\n    [item]=\"tag\"\r\n    (close)=\"closedTag($event)\"\r\n  ></angular2-smart-table-tag>\r\n</div>\r\n", dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: TagComponent, selector: "angular2-smart-table-tag", inputs: ["item"], outputs: ["close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TagsListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'angular2-smart-table-tags-list', standalone: false, template: "<div>\r\n  <angular2-smart-table-tag\r\n    *ngFor=\"let tag of tags\"\r\n    [item]=\"tag\"\r\n    (close)=\"closedTag($event)\"\r\n  ></angular2-smart-table-tag>\r\n</div>\r\n" }]
        }], propDecorators: { tags: [{
                type: Input
            }], close: [{
                type: Output
            }] } });

class Angular2SmartTableComponent {
    source;
    settings;
    rowSelect = new EventEmitter();
    userRowSelect = new EventEmitter();
    delete = new EventEmitter();
    edit = new EventEmitter();
    create = new EventEmitter();
    custom = new EventEmitter();
    deleteConfirm = new EventEmitter();
    editConfirm = new EventEmitter();
    editCancel = new EventEmitter();
    createConfirm = new EventEmitter();
    createCancel = new EventEmitter();
    rowHover = new EventEmitter();
    afterGridInit = new EventEmitter();
    dataChangeSubscription;
    tableClass;
    tableId;
    perPageSelect;
    perPageSelectLabel;
    isHideHeader;
    isHideSubHeader;
    isPagerDisplay;
    isTagListShown = true;
    rowClassFunction;
    grid; // initially undefined, but will never be set to undefined, so we do not add undefined type here
    defaultSettings = {
        mode: 'inline',
        selectMode: 'single',
        sortMode: 'multi',
        switchPageToSelectedRowPage: false,
        hideHeader: false,
        hideSubHeader: false,
        resizable: false,
        hideable: false,
        hideTagList: false,
        actions: {
            columnTitle: 'Actions',
            add: true,
            edit: true,
            delete: true,
            custom: [],
            position: 'left',
        },
        filter: {
            inputClass: '',
            debounceTime: 300,
        },
        edit: {
            inputClass: '',
            editButtonContent: 'Edit',
            saveButtonContent: 'Update',
            cancelButtonContent: 'Cancel',
            confirmSave: false,
        },
        add: {
            inputClass: '',
            addButtonContent: 'Add New',
            createButtonContent: 'Create',
            cancelButtonContent: 'Cancel',
            confirmCreate: false,
        },
        delete: {
            deleteButtonContent: 'Delete',
            confirmDelete: false,
        },
        expand: {
            buttonContent: 'Expand'
        },
        attr: {
            id: '',
            class: '',
        },
        noDataMessage: 'No data found',
        columns: {},
        pager: {
            display: true,
            page: 1,
            perPage: 10,
            perPageSelect: [],
            perPageSelectLabel: 'Per Page:',
        },
        rowClassFunction: (_) => '',
    };
    isAllSelected = false;
    onSelectRowSubscription;
    destroyed$ = new Subject();
    ngOnChanges(changes) {
        if (this.grid !== undefined) {
            // grid is already created, just update the relevant properties
            if (changes['settings']) {
                this.grid.setSettings(this.prepareSettings());
                this.updateNotVisibleColumnTagList();
            }
            if (changes['source']) {
                this.source = this.prepareSource();
                this.grid.setSource(this.source);
            }
        }
        else if (this.settings !== undefined && this.source !== undefined) {
            // create a new grid, but only if settings and source are already available
            this.source = this.prepareSource();
            this.grid = new Grid(this.source, this.prepareSettings());
            this.updateNotVisibleColumnTagList();
            this.subscribeToOnSelectRow();
            /** Delay a bit the grid init event trigger to prevent empty rows */
            setTimeout(() => {
                this.afterGridInit.emit(this.grid.dataSet);
            }, 10);
        }
        // once everything is set up, we can copy some settings
        // we use the settings from the grid, because those are enriched with the defaults
        if (this.grid !== undefined) {
            this.tableId = this.grid.settings.attr.id;
            this.tableClass = this.grid.settings.attr.class;
            this.isHideHeader = this.grid.settings.hideHeader;
            this.isHideSubHeader = this.grid.settings.hideSubHeader;
            this.isTagListShown = !(this.grid.settings.hideTagList ?? false);
            this.isPagerDisplay = this.grid.settings.pager.display;
            this.perPageSelect = this.grid.settings.pager.perPageSelect;
            this.perPageSelectLabel = this.grid.settings.pager.perPageSelectLabel;
            this.rowClassFunction = this.grid.settings.rowClassFunction;
        }
    }
    ngOnDestroy() {
        this.destroyed$.next();
    }
    onEditRowSelect(row) {
        if (this.grid.settings.selectMode === 'single') {
            this.grid.selectRow(row);
            this.emitSelectRow(row);
        }
    }
    onUserSelectRow(row) {
        if (this.grid.settings.selectMode === 'single') {
            this.grid.selectRow(row);
            this.emitUserSelectRow(row);
        }
    }
    onRowHover(row) {
        this.rowHover.emit(row);
    }
    onMultipleSelectRow(row) {
        this.grid.multipleSelectRow(row);
        // TODO: currently we make our life easy and just deselect the "select all" checkbox when needed
        //       but we do not check it, when we determine that the user has selected everything
        if (!row.isSelected)
            this.isAllSelected = false;
        this.emitUserSelectRow(row);
    }
    async onSelectAllRows() {
        this.isAllSelected = !this.isAllSelected;
        await this.grid.selectAllRows(this.isAllSelected);
        this.emitUserSelectRow(null);
    }
    onExpandRow(row) {
        this.grid.expandRow(row);
    }
    prepareSource() {
        let source;
        if (this.source instanceof DataSource) {
            source = this.source;
        }
        else if (this.source instanceof Array) {
            source = new LocalDataSource(this.source);
        }
        else {
            source = new LocalDataSource();
        }
        // we have to hook up a listener to update some variables when the data source changes
        if (this.dataChangeSubscription)
            this.dataChangeSubscription.unsubscribe();
        this.dataChangeSubscription = source.onChanged().subscribe((changes) => this.processDataChange(changes));
        return source;
    }
    processDataChange(_) {
        // here we can already assume that the source has been lifted to an instance of DataSource
        const source = this.source;
        this.isAllSelected = source.isEveryElementSelected(this.grid.settings.selectMode === 'multi_filtered', true);
    }
    prepareSettings() {
        return deepExtend({}, this.defaultSettings, this.settings);
    }
    getNotVisibleColumns() {
        return (this.grid?.getColumns() ?? []).filter(column => column.hide);
    }
    notVisibleColumnTagsList = [];
    updateNotVisibleColumnTagList() {
        this.notVisibleColumnTagsList = this.getNotVisibleColumns().map(c => ({
            key: c.id,
            value: c.title,
        }));
    }
    onShowColumn(columnId) {
        this.grid.settings.columns[columnId].hide = false;
        this.grid.recreateDataSet();
        this.updateNotVisibleColumnTagList();
    }
    onHideColumn(columnId) {
        this.grid.settings.columns[columnId].hide = true;
        this.grid.recreateDataSet();
        this.updateNotVisibleColumnTagList();
    }
    createRowSelectionEvent(row) {
        return {
            row: row,
            data: row ? row.getData() : null,
            isSelected: row ? row.getIsSelected() : null,
            source: this.source,
            selected: this.grid.getSelectedItems(),
        };
    }
    emitUserSelectRow(row) {
        this.userRowSelect.emit(this.createRowSelectionEvent(row));
        // always also emit the general event
        this.emitSelectRow(row);
    }
    emitSelectRow(row) {
        this.rowSelect.emit(this.createRowSelectionEvent(row));
    }
    isIndexOutOfRange(index) {
        const dataAmount = this.source?.count();
        return index < 0 || (typeof dataAmount === 'number' && index >= dataAmount);
    }
    subscribeToOnSelectRow() {
        if (this.onSelectRowSubscription) {
            this.onSelectRowSubscription.unsubscribe();
        }
        this.onSelectRowSubscription = this.grid.onSelectRow()
            .pipe(takeUntil(this.destroyed$))
            .subscribe((row) => {
            this.emitSelectRow(row);
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: Angular2SmartTableComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.2.1", type: Angular2SmartTableComponent, isStandalone: false, selector: "angular2-smart-table", inputs: { source: "source", settings: "settings" }, outputs: { rowSelect: "rowSelect", userRowSelect: "userRowSelect", delete: "delete", edit: "edit", create: "create", custom: "custom", deleteConfirm: "deleteConfirm", editConfirm: "editConfirm", editCancel: "editCancel", createConfirm: "createConfirm", createCancel: "createCancel", rowHover: "rowHover", afterGridInit: "afterGridInit" }, usesOnChanges: true, ngImport: i0, template: "<ng-container *ngIf=\"grid !== undefined\">\r\n<angular2-smart-table-tags-list *ngIf=\"isTagListShown\"\r\n  [tags]=\"notVisibleColumnTagsList\" (close)=\"onShowColumn($event)\"\r\n></angular2-smart-table-tags-list>\r\n\r\n<div style=\"overflow-x: auto; -webkit-overflow-scrolling: touch\">\r\n  <table [id]=\"tableId\" [ngClass]=\"tableClass\">\r\n    <thead\r\n      angular2-st-thead\r\n      *ngIf=\"!isHideHeader || !isHideSubHeader\"\r\n      [grid]=\"grid\"\r\n      [isAllSelected]=\"isAllSelected\"\r\n      [source]=\"source\"\r\n      [createConfirm]=\"createConfirm\"\r\n      [createCancel]=\"createCancel\"\r\n      (create)=\"create.emit($event)\"\r\n      (selectAllRows)=\"onSelectAllRows()\"\r\n      (hide)=\"onHideColumn($event)\"\r\n    ></thead>\r\n\r\n    <tbody\r\n      angular2-st-tbody\r\n      [grid]=\"grid\"\r\n      [source]=\"source\"\r\n      [deleteConfirm]=\"deleteConfirm\"\r\n      [editConfirm]=\"editConfirm\"\r\n      [editCancel]=\"editCancel\"\r\n      [rowClassFunction]=\"rowClassFunction\"\r\n      (edit)=\"edit.emit($event)\"\r\n      (delete)=\"delete.emit($event)\"\r\n      (custom)=\"custom.emit($event)\"\r\n      (userSelectRow)=\"onUserSelectRow($event)\"\r\n      (editRowSelect)=\"onEditRowSelect($event)\"\r\n      (multipleSelectRow)=\"onMultipleSelectRow($event)\"\r\n      (onExpandRow)=\"onExpandRow($event)\"\r\n      (rowHover)=\"onRowHover($event)\"\r\n    ></tbody>\r\n  </table>\r\n</div>\r\n<angular2-smart-table-pager\r\n  *ngIf=\"isPagerDisplay\"\r\n  [source]=\"source\"\r\n  [perPageSelect]=\"perPageSelect\"\r\n  [perPageSelectLabel]=\"perPageSelectLabel\"\r\n>\r\n</angular2-smart-table-pager>\r\n</ng-container>\r\n", styles: [":host{font-size:1rem}:host ::ng-deep *{box-sizing:border-box}:host ::ng-deep button,:host ::ng-deep input,:host ::ng-deep optgroup,:host ::ng-deep select,:host ::ng-deep textarea{color:inherit;font:inherit;margin:0}:host ::ng-deep table{line-height:1.5em;border-collapse:collapse;border-spacing:0;display:table;width:100%;max-width:100%;overflow:auto;word-break:normal;word-break:keep-all}:host ::ng-deep table tr th{font-weight:700;position:relative}:host ::ng-deep table tr th .angular2-resizer-block{width:8px;height:100%;position:absolute;right:0;top:0;cursor:col-resize}:host ::ng-deep table tr section{font-size:.75em;font-weight:700}:host ::ng-deep table tr td,:host ::ng-deep table tr th{font-size:.875em;margin:0;padding:.5em 1em}:host ::ng-deep a{color:#1e6bb8;text-decoration:none}:host ::ng-deep a:hover{text-decoration:underline}:host ::ng-deep .not-allowed{cursor:not-allowed}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: PagerComponent, selector: "angular2-smart-table-pager", inputs: ["source", "perPageSelect", "perPageSelectLabel"] }, { kind: "component", type: NgxSmartTableTbodyComponent, selector: "[angular2-st-tbody]", inputs: ["grid", "source", "deleteConfirm", "editConfirm", "editCancel", "rowClassFunction"], outputs: ["edit", "delete", "custom", "userSelectRow", "editRowSelect", "multipleSelectRow", "rowHover", "onExpandRow"] }, { kind: "component", type: NgxSmartTableTheadComponent, selector: "[angular2-st-thead]", inputs: ["grid", "source", "isAllSelected", "createConfirm", "createCancel"], outputs: ["hide", "selectAllRows", "create"] }, { kind: "component", type: TagsListComponent, selector: "angular2-smart-table-tags-list", inputs: ["tags"], outputs: ["close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: Angular2SmartTableComponent, decorators: [{
            type: Component,
            args: [{ selector: 'angular2-smart-table', standalone: false, template: "<ng-container *ngIf=\"grid !== undefined\">\r\n<angular2-smart-table-tags-list *ngIf=\"isTagListShown\"\r\n  [tags]=\"notVisibleColumnTagsList\" (close)=\"onShowColumn($event)\"\r\n></angular2-smart-table-tags-list>\r\n\r\n<div style=\"overflow-x: auto; -webkit-overflow-scrolling: touch\">\r\n  <table [id]=\"tableId\" [ngClass]=\"tableClass\">\r\n    <thead\r\n      angular2-st-thead\r\n      *ngIf=\"!isHideHeader || !isHideSubHeader\"\r\n      [grid]=\"grid\"\r\n      [isAllSelected]=\"isAllSelected\"\r\n      [source]=\"source\"\r\n      [createConfirm]=\"createConfirm\"\r\n      [createCancel]=\"createCancel\"\r\n      (create)=\"create.emit($event)\"\r\n      (selectAllRows)=\"onSelectAllRows()\"\r\n      (hide)=\"onHideColumn($event)\"\r\n    ></thead>\r\n\r\n    <tbody\r\n      angular2-st-tbody\r\n      [grid]=\"grid\"\r\n      [source]=\"source\"\r\n      [deleteConfirm]=\"deleteConfirm\"\r\n      [editConfirm]=\"editConfirm\"\r\n      [editCancel]=\"editCancel\"\r\n      [rowClassFunction]=\"rowClassFunction\"\r\n      (edit)=\"edit.emit($event)\"\r\n      (delete)=\"delete.emit($event)\"\r\n      (custom)=\"custom.emit($event)\"\r\n      (userSelectRow)=\"onUserSelectRow($event)\"\r\n      (editRowSelect)=\"onEditRowSelect($event)\"\r\n      (multipleSelectRow)=\"onMultipleSelectRow($event)\"\r\n      (onExpandRow)=\"onExpandRow($event)\"\r\n      (rowHover)=\"onRowHover($event)\"\r\n    ></tbody>\r\n  </table>\r\n</div>\r\n<angular2-smart-table-pager\r\n  *ngIf=\"isPagerDisplay\"\r\n  [source]=\"source\"\r\n  [perPageSelect]=\"perPageSelect\"\r\n  [perPageSelectLabel]=\"perPageSelectLabel\"\r\n>\r\n</angular2-smart-table-pager>\r\n</ng-container>\r\n", styles: [":host{font-size:1rem}:host ::ng-deep *{box-sizing:border-box}:host ::ng-deep button,:host ::ng-deep input,:host ::ng-deep optgroup,:host ::ng-deep select,:host ::ng-deep textarea{color:inherit;font:inherit;margin:0}:host ::ng-deep table{line-height:1.5em;border-collapse:collapse;border-spacing:0;display:table;width:100%;max-width:100%;overflow:auto;word-break:normal;word-break:keep-all}:host ::ng-deep table tr th{font-weight:700;position:relative}:host ::ng-deep table tr th .angular2-resizer-block{width:8px;height:100%;position:absolute;right:0;top:0;cursor:col-resize}:host ::ng-deep table tr section{font-size:.75em;font-weight:700}:host ::ng-deep table tr td,:host ::ng-deep table tr th{font-size:.875em;margin:0;padding:.5em 1em}:host ::ng-deep a{color:#1e6bb8;text-decoration:none}:host ::ng-deep a:hover{text-decoration:underline}:host ::ng-deep .not-allowed{cursor:not-allowed}\n"] }]
        }], propDecorators: { source: [{
                type: Input
            }], settings: [{
                type: Input
            }], rowSelect: [{
                type: Output
            }], userRowSelect: [{
                type: Output
            }], delete: [{
                type: Output
            }], edit: [{
                type: Output
            }], create: [{
                type: Output
            }], custom: [{
                type: Output
            }], deleteConfirm: [{
                type: Output
            }], editConfirm: [{
                type: Output
            }], editCancel: [{
                type: Output
            }], createConfirm: [{
                type: Output
            }], createCancel: [{
                type: Output
            }], rowHover: [{
                type: Output
            }], afterGridInit: [{
                type: Output
            }] } });

const PIPES = [
    BypassSecurityTrustPipe,
];
class PipesModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: PipesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: PipesModule, declarations: [BypassSecurityTrustPipe], exports: [BypassSecurityTrustPipe] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: PipesModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: PipesModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...PIPES],
                    exports: [...PIPES],
                }]
        }] });

const CELL_COMPONENTS = [
    CellComponent,
    EditCellDefault,
    DefaultEditor,
    CustomEditComponent,
    DefaultEditComponent,
    EditCellComponent,
    CheckboxEditorComponent,
    InputEditorComponent,
    SelectEditorComponent,
    TextareaEditorComponent,
    CustomViewComponent,
    ViewCellComponent,
];
class CellModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CellModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: CellModule, declarations: [CellComponent,
            EditCellDefault,
            DefaultEditor,
            CustomEditComponent,
            DefaultEditComponent,
            EditCellComponent,
            CheckboxEditorComponent,
            InputEditorComponent,
            SelectEditorComponent,
            TextareaEditorComponent,
            CustomViewComponent,
            ViewCellComponent], imports: [CommonModule,
            PipesModule], exports: [CellComponent,
            EditCellDefault,
            DefaultEditor,
            CustomEditComponent,
            DefaultEditComponent,
            EditCellComponent,
            CheckboxEditorComponent,
            InputEditorComponent,
            SelectEditorComponent,
            TextareaEditorComponent,
            CustomViewComponent,
            ViewCellComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CellModule, imports: [CommonModule,
            PipesModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: CellModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        PipesModule,
                    ],
                    declarations: [
                        ...CELL_COMPONENTS,
                    ],
                    exports: [
                        ...CELL_COMPONENTS,
                    ],
                }]
        }] });

const FILTER_COMPONENTS = [
    FilterDefault,
    DefaultFilter,
    FilterComponent,
    DefaultFilterComponent,
    CustomFilterComponent,
    CheckboxFilterComponent,
    InputFilterComponent,
    SelectFilterComponent,
];
class FilterModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: FilterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: FilterModule, declarations: [FilterDefault,
            DefaultFilter,
            FilterComponent,
            DefaultFilterComponent,
            CustomFilterComponent,
            CheckboxFilterComponent,
            InputFilterComponent,
            SelectFilterComponent], imports: [CommonModule], exports: [FilterDefault,
            DefaultFilter,
            FilterComponent,
            DefaultFilterComponent,
            CustomFilterComponent,
            CheckboxFilterComponent,
            InputFilterComponent,
            SelectFilterComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: FilterModule, imports: [CommonModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: FilterModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                    ],
                    declarations: [
                        ...FILTER_COMPONENTS,
                    ],
                    exports: [
                        ...FILTER_COMPONENTS,
                    ],
                }]
        }] });

class PagerModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: PagerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: PagerModule, declarations: [PagerComponent], imports: [CommonModule], exports: [PagerComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: PagerModule, imports: [CommonModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: PagerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                    ],
                    declarations: [
                        PagerComponent,
                    ],
                    exports: [
                        PagerComponent,
                    ],
                }]
        }] });

class TagsModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TagsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: TagsModule, declarations: [TagComponent,
            TagsListComponent], imports: [CommonModule], exports: [TagComponent,
            TagsListComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TagsModule, imports: [CommonModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TagsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                    ],
                    declarations: [
                        TagComponent,
                        TagsListComponent
                    ],
                    exports: [
                        TagComponent,
                        TagsListComponent
                    ],
                }]
        }] });

const TBODY_COMPONENTS = [
    TbodySaveCancelComponent,
    TbodyEditDeleteComponent,
    TbodyCustomComponent,
    TbodyExpandRowComponent,
    TbodyCustomItemComponent,
    NgxSmartTableTbodyComponent
];
class TBodyModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TBodyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: TBodyModule, declarations: [TbodySaveCancelComponent,
            TbodyEditDeleteComponent,
            TbodyCustomComponent,
            TbodyExpandRowComponent,
            TbodyCustomItemComponent,
            NgxSmartTableTbodyComponent], imports: [CommonModule,
            CellModule,
            PipesModule], exports: [TbodySaveCancelComponent,
            TbodyEditDeleteComponent,
            TbodyCustomComponent,
            TbodyExpandRowComponent,
            TbodyCustomItemComponent,
            NgxSmartTableTbodyComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TBodyModule, imports: [CommonModule,
            CellModule,
            PipesModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: TBodyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        CellModule,
                        PipesModule,
                    ],
                    declarations: [
                        ...TBODY_COMPONENTS,
                    ],
                    exports: [
                        ...TBODY_COMPONENTS,
                    ],
                }]
        }] });

const DIRECTIVES = [
    NgxResizerDirective
];
class DirectivesModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DirectivesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: DirectivesModule, declarations: [NgxResizerDirective], imports: [CommonModule], exports: [NgxResizerDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DirectivesModule, imports: [CommonModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: DirectivesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        ...DIRECTIVES,
                    ],
                    exports: [
                        ...DIRECTIVES,
                    ],
                }]
        }] });

const THEAD_COMPONENTS = [
    TheadCreateCancelComponent,
    ActionsTitleComponent,
    AddButtonComponent,
    ColumnTitleComponent,
    TheadFitlersRowComponent,
    TheadFormRowComponent,
    TheadTitlesRowComponent,
    NgxSmartTableTheadComponent
];
class THeadModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: THeadModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: THeadModule, declarations: [TheadCreateCancelComponent,
            ActionsTitleComponent,
            AddButtonComponent,
            ColumnTitleComponent,
            TheadFitlersRowComponent,
            TheadFormRowComponent,
            TheadTitlesRowComponent,
            NgxSmartTableTheadComponent], imports: [CommonModule,
            FilterModule,
            CellModule,
            DirectivesModule,
            PipesModule], exports: [TheadCreateCancelComponent,
            ActionsTitleComponent,
            AddButtonComponent,
            ColumnTitleComponent,
            TheadFitlersRowComponent,
            TheadFormRowComponent,
            TheadTitlesRowComponent,
            NgxSmartTableTheadComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: THeadModule, imports: [CommonModule,
            FilterModule,
            CellModule,
            DirectivesModule,
            PipesModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: THeadModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FilterModule,
                        CellModule,
                        DirectivesModule,
                        PipesModule
                    ],
                    declarations: [
                        ...THEAD_COMPONENTS,
                    ],
                    exports: [
                        ...THEAD_COMPONENTS,
                    ],
                }]
        }] });

class Angular2SmartTableModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: Angular2SmartTableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: Angular2SmartTableModule, declarations: [Angular2SmartTableComponent], imports: [CommonModule,
            CellModule,
            FilterModule,
            PagerModule,
            TBodyModule,
            THeadModule,
            TagsModule], exports: [Angular2SmartTableComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: Angular2SmartTableModule, imports: [CommonModule,
            CellModule,
            FilterModule,
            PagerModule,
            TBodyModule,
            THeadModule,
            TagsModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: Angular2SmartTableModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        Angular2SmartTableComponent
                    ],
                    imports: [
                        CommonModule,
                        CellModule,
                        FilterModule,
                        PagerModule,
                        TBodyModule,
                        THeadModule,
                        TagsModule
                    ],
                    exports: [
                        Angular2SmartTableComponent
                    ]
                }]
        }] });

class ServerSourceConf {
    static SORT_FIELD_KEY = '_sort';
    static SORT_DIR_KEY = '_order';
    static PAGER_PAGE_KEY = '_page';
    static PAGER_LIMIT_KEY = '_limit';
    static FILTER_FIELD_KEY = '#field#_like';
    static TOTAL_KEY = 'x-total-count';
    static DATA_KEY = '';
    endPoint;
    sortFieldKey;
    sortDirKey;
    pagerPageKey;
    pagerLimitKey;
    filterFieldKey;
    totalKey;
    dataKey;
    constructor({ endPoint = '', sortFieldKey = '', sortDirKey = '', pagerPageKey = '', pagerLimitKey = '', filterFieldKey = '', totalKey = '', dataKey = '' } = {}) {
        this.endPoint = endPoint ? endPoint : '';
        this.sortFieldKey = sortFieldKey ? sortFieldKey : ServerSourceConf.SORT_FIELD_KEY;
        this.sortDirKey = sortDirKey ? sortDirKey : ServerSourceConf.SORT_DIR_KEY;
        this.pagerPageKey = pagerPageKey ? pagerPageKey : ServerSourceConf.PAGER_PAGE_KEY;
        this.pagerLimitKey = pagerLimitKey ? pagerLimitKey : ServerSourceConf.PAGER_LIMIT_KEY;
        this.filterFieldKey = filterFieldKey ? filterFieldKey : ServerSourceConf.FILTER_FIELD_KEY;
        this.totalKey = totalKey ? totalKey : ServerSourceConf.TOTAL_KEY;
        this.dataKey = dataKey ? dataKey : ServerSourceConf.DATA_KEY;
    }
}

class ServerDataSource extends LocalDataSource {
    http;
    conf;
    lastRequestCount = 0;
    constructor(http, conf = {}) {
        super();
        this.http = http;
        this.conf = new ServerSourceConf(conf);
        if (!this.conf.endPoint) {
            throw new Error('At least endPoint must be specified as a configuration of the server data source.');
        }
    }
    count() {
        return this.lastRequestCount;
    }
    getAll() {
        return this.loadData(false, false, false);
    }
    getElements() {
        return this.loadData(true, true, true);
    }
    getFilteredAndSorted() {
        return this.loadData(true, true, false);
    }
    loadData(filtered, sorted, paginated) {
        return this.requestElements(filtered, sorted, paginated)
            .pipe(map(res => {
            this.lastRequestCount = this.extractTotalFromResponse(res);
            // TODO: the following two lines are obviously incorrect
            //       but whoever hacked this ServerDataSource into the project did not think about compatibility to the interface
            this.data = this.extractDataFromResponse(res);
            this.filteredAndSorted = this.data;
            return this.data;
        })).toPromise();
    }
    /**
     * Extracts array of data from server response
     * @param res
     * @returns {any}
     */
    extractDataFromResponse(res) {
        const rawData = res.body;
        const data = !!this.conf.dataKey ? getDeepFromObject(rawData, this.conf.dataKey, []) : rawData;
        if (data instanceof Array) {
            return data;
        }
        throw new Error(`Data must be an array. Please check that data extracted from the server response by the key '${this.conf.dataKey}' exists and is array.`);
    }
    /**
     * Extracts total rows count from the server response
     * Looks for the count in the headers first, then in the response body
     * @param res
     * @returns {any}
     */
    extractTotalFromResponse(res) {
        if (res.headers.has(this.conf.totalKey)) {
            return +res.headers.get(this.conf.totalKey);
        }
        else {
            const rawData = res.body;
            return getDeepFromObject(rawData, this.conf.totalKey, 0);
        }
    }
    requestElements(filtered, sorted, paginated) {
        let httpParams = new HttpParams();
        if (filtered)
            httpParams = this.addFilterRequestParams(httpParams);
        if (sorted)
            httpParams = this.addSortRequestParams(httpParams);
        if (paginated)
            httpParams = this.addPagerRequestParams(httpParams);
        return this.http.get(this.conf.endPoint, { params: httpParams, observe: 'response' });
    }
    addSortRequestParams(httpParams) {
        if (this.sortConf) {
            let fields = [];
            let directions = [];
            this.sortConf.forEach((fieldConf) => {
                if (fieldConf.direction !== null) {
                    fields.push(fieldConf.field);
                    directions.push(fieldConf.direction.toUpperCase());
                }
            });
            httpParams = httpParams.set(this.conf.sortFieldKey, fields.join(','));
            httpParams = httpParams.set(this.conf.sortDirKey, directions.join(','));
        }
        return httpParams;
    }
    addFilterRequestParams(httpParams) {
        this.filterConf.forEach((fieldConf) => {
            if (fieldConf['search']) {
                httpParams = httpParams.set(this.conf.filterFieldKey.replace('#field#', fieldConf['field']), fieldConf['search']);
            }
        });
        return httpParams;
    }
    addPagerRequestParams(httpParams) {
        httpParams = httpParams.set(this.conf.pagerPageKey, this.pagingConf.page);
        httpParams = httpParams.set(this.conf.pagerLimitKey, this.pagingConf.perPage);
        return httpParams;
    }
}

/*
 * Public API Surface of angular2-smart-table
 */

/**
 * Generated bundle index. Do not edit.
 */

export { Angular2SmartTableComponent, Angular2SmartTableModule, Cell, Column, DataSet, DataSource, DefaultEditor, DefaultFilter, LocalDataSource, Row, ServerDataSource };
//# sourceMappingURL=angular2-smart-table.mjs.map
